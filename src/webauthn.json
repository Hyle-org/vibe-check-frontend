{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":11352359972828853842,"abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":56},"visibility":"public"},{"name":"tx_hash_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"tx_hash","type":{"kind":"array","length":43,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"program_outputs","type":{"kind":"struct","path":"ProgramOutputs","fields":[{"name":"authenticator_data","type":{"kind":"array","length":37,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"client_data_json_len","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"client_data_json","type":{"kind":"array","length":255,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"public"}],"param_witnesses":{"identity":[{"start":12,"end":68}],"identity_len":[{"start":11,"end":12}],"initial_state":[{"start":2,"end":6}],"initial_state_len":[{"start":1,"end":2}],"next_state":[{"start":7,"end":11}],"next_state_len":[{"start":6,"end":7}],"program_outputs":[{"start":112,"end":533}],"tx_hash":[{"start":69,"end":112}],"tx_hash_len":[{"start":68,"end":69}],"version":[{"start":0,"end":1}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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MGkixkBrUjdMmogx0JrOOU6YiDHRmuo+ZzFVVM1iqqiaMMlmojXVfU6YZDPRmuo+J0yymWhNdZ8TJtlMtKa6zwlTiiZa1VoKphRNtCYN1oQpRROtqe5zwpSiidZU9zlhStFEa6r7nDClaKI11X1OmFI00ZrqPidMO5loTXWfE6adTLSqMzWv76h8Kq3qTE031X3Obqr7nN1U9zlhZtJEa6r7nDAzaaI11X1OmJk00ZrqPifMXploTXWfE2avTLSqhAzMXplowfnbC1pYInWdWoT5HNO9NdV9TpjPMdGqMiNTlRmZprrPSXZ1XtCq9grIrs4LWtVegcrVOVWuzglzdYZzjoepZ2TCzKSJ1pS/PWBm0kRryt8er28mXXeDHq8vG00A9bkAHws1j0e7f4h+/xDj/iGeMYsty00PmGRzHa48YJLNRGuq+zxgks1Ea6r7PGCSzURrqvs8YErRRGt6DT9gStFEq3oNhylFE62p7vOAKUUTranu84ApRROtqe7zgClFE62p7vOAKUUDLUw7uQ5XHjDtZKI11X0eMO1kojUdIThg2slEazqOecBEjOtw5QETMSZaU93nARMxJlpT3ecBEzEmWlPd5wETMSZaU93nAZP1JVpT3ecBk/UlWlPd5wGT9SVaU7jygKkJ1zHhA6YmTPfWJDM4YGrCRGuKGx4qNeGhUhMevapoVXsFNBFjoFXtFdBEjIHWpG44YCLGcM4RJmJMtKa6z2OYKqrOX1RFa6qoOmCSzZD1gkk2E62p7vOASTYDLUyyGbJeMMlmojXVfR4wpWiirabVBUwpmmhNGqwDphRNtKa6zwOmFA20MKVoolXlb2FK0ZD1gilFE21V0arytzDtZMh6wbSTS9r2gGknE60of3vSis7UnLSiMzUnLWu+TbSius+TVlT3edKK6j5PWlH+tj1gZtJl1uukFdV9nrSius+TVpS/PWlFdZ8nraju86QV1X2etKL8bXvA7JXLhMxJK6r7PGnB+dsL2upJLZ60okTqSSuq+zxpwauLC1pRZuSkFWVG2qOI6j5PWlH+9qRV7RWQXZ0XtFVFK8rfnrSi/O1JKzrneNKKekZOWlHPSHvAzKSJVpS/PWlF+duT9r27QU+A+u4AdzePnkP0+4cY9w8x7x/iGbPYqty0Pf6BZHM7vnwxs+2/3hoYP39q+9Sn9k99qnzqU/VTn2qf+lT/1KfGpz41P/Wp4zOf6p96Nvqnno3+qWejf+rZ6J96Nvqnno3+qWejf+rZ6J96Nvqnno3xqWdjfOrZGJ96Nsanno3xqWdjfOrZGJ96Nsanno3xqWdjfOrZmJ96Nuanno35qWdjfurZmJ96Nuanno35qWdjfurZmJ96Nuanno3jU8/G8aln4/jUs/EPolb7/Pqpuj8+fur62ajll0+18vFT189G7V8XeHXWj5+6fjbqL1zt18ewzk+d//B/vv/3H77/pz/+4c/nR/7r3/3Hj//80w9/+vHnf/zp//7b3/7N+bP/Dw==","file_map":{"1":{"source":"use crate::cmp::Ord;\n\n// TODO: Once we fully move to the new SSA pass this module can be removed and replaced\n// by the methods in the `slice` module\nimpl<T, N> [T; N] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u64 {}\n\n    pub fn sort(self) -> Self where T: Ord {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        let sorted_index = self.get_sorting_index(ordering);\n        let mut result = self;\n        // Ensure the indexes are correct\n        for i in 0..N {\n            let pos = find_index(sorted_index, i);\n            assert(sorted_index[pos] == i);\n        }\n        // Sort the array using the indexes\n        for i in 0..N {\n            result[i] = self[sorted_index[i]];\n        }\n        // Ensure the array is sorted\n        for i in 0..N - 1 {\n            assert(ordering(result[i], result[i + 1]));\n        }\n\n        result\n    }\n\n    /// Returns the index of the elements in the array that would sort it, using the provided custom sorting function.\n    unconstrained fn get_sorting_index<Env>(self, ordering: fn[Env](T, T) -> bool) -> [u64; N] {\n        let mut result = [0; N];\n        let mut a = self;\n        for i in 0..N {\n            result[i] = i;\n        }\n        for i in 1..N {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                    let old_j = result[j];\n                    result[j] = result[i];\n                    result[i] = old_j;\n                }\n            }\n        }\n        result\n    }\n\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\n// helper function used to look up the position of a value in an array of Field\n// Note that function returns 0 if the value is not found\nunconstrained fn find_index<N>(a: [u64; N], find: u64) -> u64 {\n    let mut result = 0;\n    for i in 0..a.len() {\n        if a[i] == find {\n            result = i;\n        }\n    }\n    result\n}\n","path":"std/array.nr"},"46":{"source":"use dep::std;\n\npub fn prefix_sha256_hash<N>(prefix_length: u8, input: [u8; N]) -> [u8; 32] {\n    let mut result = [0; 32];\n    assert([1, 2, 3, 113, 114, 133, 134, 242, 243].any(|x| x == prefix_length), \"Length is not supported\");\n    if prefix_length == 1 {\n        result = std::hash::sha256(prefix(input, [0; 1]));\n    }\n    if prefix_length == 2 {\n        result = std::hash::sha256(prefix(input, [0; 2]));\n    }\n    if prefix_length == 3 {\n        result = std::hash::sha256(prefix(input, [0; 3]));\n    }\n    if prefix_length == 113 {\n        result = std::hash::sha256(prefix(input, [0; 113]));\n    }\n    if prefix_length == 114 {\n        result = std::hash::sha256(prefix(input, [0; 114]));\n    }\n    if prefix_length == 133 {\n        result = std::hash::sha256(prefix(input, [0; 133]));\n    }\n    if prefix_length == 134 {\n        result = std::hash::sha256(prefix(input, [0; 134]));\n    }\n    if prefix_length == 242 {\n        result = std::hash::sha256(prefix(input, [0; 242]));\n    }\n    if prefix_length == 243 {\n        result = std::hash::sha256(prefix(input, [0; 243]));\n    }\n    result\n}\n\n\npub fn concatenate_arrays(a: [u8; 37], b: [u8; 32]) -> [u8; 69] {\n    let mut result = [0; 69];\n    for i in 0..37 {\n        result[i] = a[i];\n    }\n    for i in 0..32 {\n        result[i+37] = b[i];\n    }\n    result\n}\n\npub fn check_pubkey_matches_identity(pub_key_x: [u8; 32], pub_key_y: [u8; 32], identity: str<56>) {\n    // Compute the publickey as concatenation of pub_key_x and pub_key_y\n    let mut pub_key = [0; 64];\n    for i in 0..32 {\n        pub_key[i] = pub_key_x[i];\n    }\n    for j in 0..32 {\n        pub_key[j+32] = pub_key_y[j];\n    }\n    // Compute the address as the hash of the publickey\n    let address: [u8; 32] = std::hash::sha256(pub_key);\n\n    // identity is the last 20bytes of the address.\n    // Assert that there is a match between identity provided and identity computed from pubkeys\n    for k in 0..20 {\n        assert(address[12 + k] == identity.from_hex_to_uint_slice(2*k, 2*k + 2) as u8);\n    }\n}\n\n\nfn prefix<N, M>(input: [u8; N], mut result: [u8; M]) -> [u8; M] {\n    for i in 0..M {\n        result[i] = input[i];\n    }\n    result\n}","path":"/home/maximilien/cairo-erc20-runner/noir-webauthn/src/utils.nr"},"47":{"source":"mod utils;\n\nuse dep::std;\nuse dep::std::println;\nuse crate::utils::{prefix_sha256_hash, concatenate_arrays, check_pubkey_matches_identity};\n\nglobal CLIENT_DATA_JSON_LEN = 255;\n\nstruct ProgramOutputs {\n    authenticator_data: [u8; 37],\n    client_data_json_len: u8,\n    client_data_json: [u8; CLIENT_DATA_JSON_LEN],\n    signature: [u8; 64],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n}\n\n\nfn main(\n    version: pub u32,\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    identity_len: pub u8,\n    identity: pub str<56>,\n    tx_hash_len: pub u32,\n    tx_hash: pub [u8; 43],\n    program_outputs: pub ProgramOutputs\n) {\n    let client_data_json_hash = prefix_sha256_hash(program_outputs.client_data_json_len, program_outputs.client_data_json);\n    let concat = concatenate_arrays(program_outputs.authenticator_data, client_data_json_hash);\n    let hashed_data = std::hash::sha256(concat);\n\n    // Verifying pub_key matches the identity\n    check_pubkey_matches_identity(program_outputs.pub_key_x, program_outputs.pub_key_y, identity);\n\n\n    // The txhash IS the challenge\n    for i in 0..(tx_hash.len()) {\n        assert(tx_hash[i] == program_outputs.client_data_json[36 + i]);\n    }\n\n    let valid_signature = std::ecdsa_secp256r1::verify_signature(program_outputs.pub_key_x, program_outputs.pub_key_y, program_outputs.signature, hashed_data);\n    \n    assert(valid_signature);\n    assert(tx_hash_len == 43);\n    assert(identity_len == 56);\n}\n\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_134() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,125,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // Padding with 121 zeros (134+121 = 255) \n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0\n    ];\n    let signature = [80,114,197,245,128,150,206,160,135,105,51,205,42,143,25,53,119,97,166,196,95,98,53,63,168,171,63,85,41,42,196,134,26,198,126,179,109,99,41,92,86,45,240,238,196,106,77,219,146,196,183,80,225,170,66,218,169,244,230,252,61,213,29,201];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [201,91,99,172,65,154,80,154,189,195,194,210,62,219,224,36,43,134,143,236,137,178,121,35,112,146,103,238,37,100,145,26];\n    let pub_key_y = [169,8,63,83,58,93,192,39,114,115,138,176,56,254,162,127,93,19,156,93,51,9,194,161,253,10,203,128,171,254,255,83];\n\n    let program_outputs = ProgramOutputs {\n            authenticator_data,\n            client_data_json_len: 134,\n            client_data_json,\n            signature,\n            pub_key_x,\n            pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 1;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 1;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 56;\n    let identity = \"c59b18d3bdaccb4d689048559a9bb6e8265293bf.ecdsa_secp256r1\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        program_outputs,\n    );\n}\n\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_243() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,44,34,111,116,104,101,114,95,107,101,121,115,95,99,97,110,95,98,101,95,97,100,100,101,100,95,104,101,114,101,34,58,34,100,111,32,110,111,116,32,99,111,109,112,97,114,101,32,99,108,105,101,110,116,68,97,116,97,74,83,79,78,32,97,103,97,105,110,115,116,32,97,32,116,101,109,112,108,97,116,101,46,32,83,101,101,32,104,116,116,112,115,58,47,47,103,111,111,46,103,108,47,121,97,98,80,101,120,34,125,\n        0,0,0,0,0,0,0,0,0,0,0,0 // Padding with 12 zeros (243+12 = 255) \n    ];\n    let signature = [35,9,110,138,212,71,172,124,13,7,194,158,153,63,87,67,67,25,22,122,101,253,159,175,106,50,52,157,164,70,148,46,126,152,146,190,137,37,199,95,249,115,198,94,237,198,18,23,200,185,52,157,189,205,144,63,212,29,177,20,24,255,160,127];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [15,206,241,12,21,160,54,11,79,72,44,109,43,45,101,54,210,243,13,236,51,33,47,66,187,38,60,249,64,70,37,252];\n    let pub_key_y = [43,221,114,86,240,184,224,51,237,41,173,85,147,130,225,150,159,150,44,23,57,92,82,37,27,40,69,123,252,224,3,197];\n    \n    let program_outputs = ProgramOutputs {\n        authenticator_data,\n        client_data_json_len: 243,\n        client_data_json,\n        signature,\n        pub_key_x,\n        pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 1;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 1;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 56;\n    let identity = \"3f368bf90c71946fc7b0cde9161ace42985d235f.ecdsa_secp256r1\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        program_outputs,\n    );\n}\n\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_243_bis() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,44,34,111,116,104,101,114,95,107,101,121,115,95,99,97,110,95,98,101,95,97,100,100,101,100,95,104,101,114,101,34,58,34,100,111,32,110,111,116,32,99,111,109,112,97,114,101,32,99,108,105,101,110,116,68,97,116,97,74,83,79,78,32,97,103,97,105,110,115,116,32,97,32,116,101,109,112,108,97,116,101,46,32,83,101,101,32,104,116,116,112,115,58,47,47,103,111,111,46,103,108,47,121,97,98,80,101,120,34,125,\n        0,0,0,0,0,0,0,0,0,0,0,0 // Padding with 12 zeros (243+12 = 255) \n    ];\n    let signature = [216,184,64,61,79,81,150,39,72,191,167,234,52,253,225,66,52,192,76,159,65,164,134,34,212,255,104,99,14,53,71,115,0,190,96,135,49,186,213,189,93,36,212,143,36,92,27,42,44,103,95,153,46,59,158,22,223,196,84,102,51,209,135,233];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [35,250,194,235,47,86,159,70,36,137,145,195,83,245,203,137,12,28,43,171,167,226,44,90,199,107,235,0,229,229,133,67];\n    let pub_key_y = [84,107,152,100,72,140,98,57,186,30,76,187,129,194,209,158,96,37,254,211,60,198,27,227,167,247,204,51,145,53,120,95];\n\n    let program_outputs = ProgramOutputs {\n        authenticator_data,\n        client_data_json_len: 243,\n        client_data_json,\n        signature,\n        pub_key_x,\n        pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 1;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 1;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 56;\n    let identity = \"ae0e5100ea7d28905ce690194c0717cd93756a20.ecdsa_secp256r1\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        program_outputs,\n    );\n}\n","path":"/home/maximilien/cairo-erc20-runner/noir-webauthn/src/main.nr"},"48":{"source":"use dep::std::println;\n\nglobal UPPERCASE_A_INDEX: u8 = 65;\nglobal UPPERCASE_Z_INDEX: u8 = 90;\nglobal LOWERCASE_A_INDEX: u8 = 97;\nglobal LOWERCASE_Z_INDEX: u8 = 122;\nglobal ZERO_INDEX: u8 = 48;\nglobal NINE_INDEX: u8 = 57;\nglobal ASCII_TABLE_START_INDEX: u8 = 0;\nglobal SORTED_ASCII_TABLE: [str<1>; 127] = [    \n    \"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\t\",\"\\n\",\"\\0\",\"\\0\",\"\\r\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\n    \" \",\"!\",\"\\\"\",\"#\",\"$\",\"%\",\"&\",\"'\",\"(\",\")\",\"*\",\"+\",\",\",\"-\",\".\",\"/\",\n    \"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\n    \":\",\";\",\"<\",\"=\",\">\",\"?\",\"@\",\n    \"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\",\n    \"[\",\"\\\\\",\"]\",\"^\",\"_\",\"`\",\n    \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\n    \"{\",\"|\",\"}\",\"~\"\n];\n\n// Functions \nfn code_at<N>(s: str<N>, index: u64) -> u8 {\n    assert(index < N);\n    s.as_bytes()[index]\n}\n\nfn char_at<N>(s: str<N>, index: u64) -> str<1> {\n    let byte = code_at(s, index);\n    let ascii_index = byte - ASCII_TABLE_START_INDEX;\n    SORTED_ASCII_TABLE[ascii_index]\n}\n\nfn index_of<N, M>(s: str<N>, substr: str<M>) -> i64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    for i in 0..N {\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            index = i as i64;\n            match_count += 1;\n        } else if (index != -1) & (i - index < M) {\n            if (str_bytes[i] != substr_bytes[i - index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    // If the match count is not equal to the length of the substring,\n    // then the substring is not in the string\n    // Can happen when looking at a substring that is at the end of the string\n    // but the match is only partial\n    if match_count != M {\n        index = -1;\n    }\n\n    index\n}\n\nfn last_index_of<N, M>(s: str<N>, substr: str<M>) -> i64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    let mut final_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    for i in 0..N {\n        if (match_count == M) {\n            final_index = temp_index;\n            temp_index = -1;\n            match_count = 0;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        final_index = temp_index;\n    }\n\n    final_index\n}\n\n// We use Field instead of integers for the Vector here as integers \n// don't seem to work well with Vectors at the moment\nfn indexes_of<N, M>(s: str<N>, substr: str<M>) -> Vec<Field> {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    let mut indexes: Vec<Field> = Vec::new();\n    for i in 0..N {\n        if (match_count == M) {\n            indexes.push(temp_index as Field);\n            temp_index = -1;\n            match_count = 0;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        indexes.push(temp_index as Field);\n    }\n\n    indexes\n}\n\nfn contains<N, M>(s: str<N>, substr: str<M>) -> bool {\n    index_of(s, substr) != -1\n}\n\nfn occurrences_of<N, M>(s: str<N>, substr: str<M>) -> u64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    let mut occurrences = 0;\n    for i in 0..N {\n        if (match_count == M) {\n            temp_index = -1;\n            match_count = 0;\n            occurrences += 1;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        occurrences += 1;\n    }\n\n    occurrences\n}\n\nfn digit_at<N>(s: str<N>, index: u64) -> u8 {\n    let byte = s.as_bytes()[index];\n    assert((byte >= ZERO_INDEX) & (byte <= NINE_INDEX), \"Character is not a digit\");\n    byte - ZERO_INDEX\n}\n\nfn hex_digit_at<N>(s: str<N>, index: u64) -> u8 {\n    let byte = s.as_bytes()[index];\n    if (byte >= ZERO_INDEX) & (byte <= NINE_INDEX) {\n        byte - ZERO_INDEX\n    } else if (byte >= UPPERCASE_A_INDEX) & (byte <= UPPERCASE_Z_INDEX) {\n        byte - UPPERCASE_A_INDEX + 10\n    } else if (byte >= LOWERCASE_A_INDEX) & (byte <= LOWERCASE_Z_INDEX) {\n        byte - LOWERCASE_A_INDEX + 10\n    } else {\n        assert(false, \"Character is not a hex digit\");\n        0\n    }\n}\n\nfn to_uint_slice<N>(s: str<N>, start: u64, end: u64) -> u64 {\n    let mut result = 0;\n    for i in start..end {\n        let digit = digit_at(s, i);\n        result = result * 10 + digit as u64;\n    }\n    result\n}\n\nfn to_uint<N>(s: str<N>) -> u64 {\n    to_uint_slice(s, 0, N)\n}\n\nfn to_int<N>(s: str<N>) -> i64 {\n    if char_at(s, 0) == \"-\" {\n        -1 * to_uint_slice(s, 1, N) as i64\n    } else {\n        to_uint_slice(s, 0, N) as i64\n    }\n}\n\nfn from_hex_to_uint_slice<N>(s: str<N>, start: u64, end: u64) -> u64 {\n    let mut result = 0;\n    for i in start..end {\n        let digit = hex_digit_at(s, i);\n        result = result * 16 + digit as u64;\n    }\n    result\n}\n\nfn from_hex_to_uint<N>(s: str<N>, with_prefix: bool) -> u64 {\n    if with_prefix {\n        from_hex_to_uint_slice(s, 2, N)\n    } else {\n        from_hex_to_uint_slice(s, 0, N)\n    }\n}\n\nfn to_array_of_chars<N>(s: str<N>) -> [str<1>; N] {\n    let mut result: [str<1>; N] = [\" \"; N];\n    for i in 0..N {\n        result[i] = char_at(s, i);\n    }\n    result\n}\n\n// Struct\n\nstruct String<N> {\n    value: str<N>,\n    len: u64,\n}\n\n// Implementation over String struct\n\nimpl<N> String<N> {\n    fn new(value: str<N>) -> Self {\n        Self { value, len: N }\n    }\n\n    fn code_at(self: Self, index: u64) -> u8 {\n        code_at(self.value, index)\n    }\n\n    fn char_at(self: Self, index: u64) -> str<1> {\n        char_at(self.value, index)\n    }\n\n    fn index_of<M>(self: Self, substr: str<M>) -> i64 {\n        index_of(self.value, substr)\n    }\n\n    fn last_index_of<M>(self: Self, substr: str<M>) -> i64 {\n        last_index_of(self.value, substr)\n    }\n\n    fn indexes_of<M>(self: Self, substr: str<M>) -> Vec<Field> {\n        indexes_of(self.value, substr)\n    }\n\n    fn contains<M>(self: Self, substr: str<M>) -> bool {\n        contains(self.value, substr)\n    }\n\n    fn occurrences_of<M>(self: Self, substr: str<M>) -> u64 {\n        occurrences_of(self.value, substr)\n    }\n\n    fn digit_at(self: Self, index: u64) -> u8 {\n        digit_at(self.value, index)\n    }\n\n    fn hex_digit_at(self: Self, index: u64) -> u8 {\n        hex_digit_at(self.value, index)\n    }\n\n    fn to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        to_uint_slice(self.value, start, end)\n    }\n\n    fn to_uint(self: Self) -> u64 {\n        to_uint_slice(self.value, 0, self.len)\n    }\n\n    fn to_int(self: Self) -> i64 {\n        to_int(self.value)\n    }\n\n    fn from_hex_to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        from_hex_to_uint_slice(self.value, start, end)\n    }\n\n    fn from_hex_to_uint(self: Self, with_prefix: bool) -> u64 {\n        from_hex_to_uint(self.value, with_prefix)\n    }\n\n    fn to_array_of_chars(self: Self) -> [str<1>; N] {\n        to_array_of_chars(self.value)\n    }\n}\n\n// Trait\ntrait StringTrait {\n    fn code_at(self, index: u64) -> u8;\n    fn char_at(self, index: u64) -> str<1>;\n    fn index_of<M>(self, substr: str<M>) -> i64;\n    fn last_index_of<M>(self, c: str<M>) -> i64;\n    fn indexes_of<M>(self, c: str<M>) -> Vec<Field>;\n    fn contains<M>(self, substr: str<M>) -> bool;\n    fn occurrences_of<M>(self, c: str<M>) -> u64;\n    fn digit_at(self, index: u64) -> u8;\n    fn hex_digit_at(self, index: u64) -> u8;\n    fn to_uint_slice(self, start: u64, end: u64) -> u64;\n    fn to_uint(self) -> u64;\n    fn to_int(self) -> i64;\n    fn from_hex_to_uint_slice(self, start: u64, end: u64) -> u64;\n    fn from_hex_to_uint(self, with_prefix: bool) -> u64;\n}\n\n// Implementation for str type\nimpl<N> StringTrait for str<N> {\n    fn code_at(self: Self, index: u64) -> u8 {\n        code_at(self, index)\n    }\n\n    fn char_at(self: Self, index: u64) -> str<1> {\n        char_at(self, index)\n    }\n\n    fn index_of<M>(self: Self, substr: str<M>) -> i64 {\n        index_of(self, substr)\n    }\n\n    fn last_index_of<M>(self: Self, substr: str<M>) -> i64 {\n        last_index_of(self, substr)\n    }\n\n    fn indexes_of<M>(self: Self, substr: str<M>) -> Vec<Field> {\n        indexes_of(self, substr)\n    }\n\n    fn contains<M>(self: Self, substr: str<M>) -> bool {\n        contains(self, substr)\n    }\n\n    fn occurrences_of<M>(self: Self, substr: str<M>) -> u64 {\n        occurrences_of(self, substr)\n    }\n\n    fn digit_at(self: Self, index: u64) -> u8 {\n        digit_at(self, index)\n    }\n\n    fn hex_digit_at(self: Self, index: u64) -> u8 {\n        hex_digit_at(self, index)\n    }\n\n    fn to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        to_uint_slice(self, start, end)\n    }\n\n    fn to_uint(self: Self) -> u64 {\n        to_uint_slice(self, 0, N)\n    }\n\n    fn to_int(self: Self) -> i64 {\n        to_int(self)\n    }\n\n    fn from_hex_to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        from_hex_to_uint_slice(self, start, end)\n    }\n\n    fn from_hex_to_uint(self: Self, with_prefix: bool) -> u64 {\n        from_hex_to_uint(self, with_prefix)\n    }\n}\n\n// Tests for String struct\n#[test]\nfn test_init() {\n    let s = String::new(\"hello\");\n    assert(s.len == 5);\n    assert(s.value == \"hello\");\n}\n\n#[test]\nfn test_char_at() {\n    let s = String::new(\"hello\");\n    assert(s.char_at(0) == \"h\");\n    assert(s.char_at(1) == \"e\");\n    assert(s.char_at(2) == \"l\");\n    assert(s.char_at(3) == \"l\");\n    assert(s.char_at(4) == \"o\");\n}\n\n#[test]\nfn test_code_at() {\n    let s = String::new(\"hello\");\n    assert(s.code_at(0) == 104);\n    assert(s.code_at(1) == 101);\n    assert(s.code_at(2) == 108);\n    assert(s.code_at(3) == 108);\n    assert(s.code_at(4) == 111);\n}\n\n#[test]\nfn test_index_of() {\n    let s = String::new(\"hello\");\n    // Characters\n    assert(s.index_of(\"h\") == 0);\n    assert(s.index_of(\"e\") == 1);\n    assert(s.index_of(\"l\") == 2);\n    assert(s.index_of(\"o\") == 4);\n    assert(s.index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.index_of(\"he\") == 0);\n    assert(s.index_of(\"el\") == 1);\n    assert(s.index_of(\"ll\") == 2);\n    assert(s.index_of(\"lo\") == 3);\n    assert(s.index_of(\"hello\") == 0);\n    assert(s.index_of(\"ow\") == -1);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.index_of(\"some\") == 0);\n    assert(sentence.index_of(\"sentence\") == 5);\n    assert(sentence.index_of(\"with\") == 14);\n    assert(sentence.index_of(\"repetition\") == 24);\n    assert(sentence.index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.index_of(\"ti\") == 28);\n}\n\n#[test]\nfn test_last_index_of() {\n    let s = String::new(\"hello\");\n    assert(s.last_index_of(\"h\") == 0);\n    assert(s.last_index_of(\"e\") == 1);\n    assert(s.last_index_of(\"l\") == 3);\n    assert(s.last_index_of(\"o\") == 4);\n    assert(s.last_index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.last_index_of(\"he\") == 0);\n    assert(s.last_index_of(\"el\") == 1);\n    assert(s.last_index_of(\"ll\") == 2);\n    assert(s.last_index_of(\"lo\") == 3);\n    assert(s.last_index_of(\"hello\") == 0);\n    assert(s.last_index_of(\"ow\") == -1);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.last_index_of(\"some\") == 19);\n    assert(sentence.last_index_of(\"sentence\") == 5);\n    assert(sentence.last_index_of(\"with\") == 14);\n    assert(sentence.last_index_of(\"repetition\") == 24);\n    assert(sentence.last_index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.last_index_of(\"ti\") == 30);\n}\n\n#[test]\nfn test_indexes_of() {\n    let s = String::new(\"hello\");\n    assert(s.indexes_of(\"h\").get(0) == 0);\n    assert(s.indexes_of(\"e\").get(0) == 1);\n    assert(s.indexes_of(\"l\").get(0) == 2);\n    assert(s.indexes_of(\"l\").get(1) == 3);\n    assert(s.indexes_of(\"o\").get(0) == 4);\n    assert(s.indexes_of(\"a\").len() == 0);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.indexes_of(\"some\").get(0) == 0);\n    assert(sentence.indexes_of(\"some\").get(1) == 19);\n    assert(sentence.indexes_of(\"sentence\").get(0) == 5);\n    assert(sentence.indexes_of(\"with\").get(0) == 14);\n    assert(sentence.indexes_of(\"repetition\").get(0) == 24);\n    assert(sentence.indexes_of(\"some sentence with some repetition\").get(0) == 0);\n    assert(sentence.indexes_of(\"ti\").get(0) == 28);\n    assert(sentence.indexes_of(\"ti\").get(1) == 30);\n    assert(sentence.indexes_of(\"a\").len() == 0);\n}\n\n#[test]\nfn test_contains() {\n    let s = String::new(\"hello\");\n    assert(s.contains(\"h\"));\n    assert(s.contains(\"e\"));\n    assert(s.contains(\"l\"));\n    assert(s.contains(\"o\"));\n    assert(!s.contains(\"a\"));\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.contains(\"some\"));\n    assert(sentence.contains(\"sentence\"));\n    assert(sentence.contains(\"with\"));\n    assert(sentence.contains(\"repetition\"));\n    assert(sentence.contains(\"ti\"));\n    assert(!sentence.contains(\"hello\"));\n    assert(!sentence.contains(\"a\"));\n}\n\n#[test]\nfn test_occurrences_of() {\n    let s = String::new(\"hello\");\n    assert(s.occurrences_of(\"h\") == 1);\n    assert(s.occurrences_of(\"e\") == 1);\n    assert(s.occurrences_of(\"l\") == 2);\n    assert(s.occurrences_of(\"o\") == 1);\n    assert(s.occurrences_of(\"a\") == 0);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.occurrences_of(\"some\") == 2);\n    assert(sentence.occurrences_of(\"sentence\") == 1);\n    assert(sentence.occurrences_of(\"with\") == 1);\n    assert(sentence.occurrences_of(\"repetition\") == 1);\n    assert(sentence.occurrences_of(\"ti\") == 2);\n    assert(sentence.occurrences_of(\"hello\") == 0);\n    assert(sentence.occurrences_of(\"a\") == 0);\n}\n\n#[test]\nfn test_digit_at() {\n    let s = String::new(\"20231219\");\n    assert(s.digit_at(0) == 2);\n    assert(s.digit_at(1) == 0);\n    assert(s.digit_at(2) == 2);\n    assert(s.digit_at(3) == 3);\n    assert(s.digit_at(4) == 1);\n    assert(s.digit_at(5) == 2);\n    assert(s.digit_at(6) == 1);\n    assert(s.digit_at(7) == 9);\n}\n\n#[test]\nfn test_hex_digit_at() {\n    let s = String::new(\"0x1324ABCDEF\");\n    assert(s.hex_digit_at(2) == 1);\n    assert(s.hex_digit_at(3) == 3);\n    assert(s.hex_digit_at(4) == 2);\n    assert(s.hex_digit_at(5) == 4);\n    assert(s.hex_digit_at(6) == 10);\n    assert(s.hex_digit_at(7) == 11);\n    assert(s.hex_digit_at(8) == 12);\n    assert(s.hex_digit_at(9) == 13);\n    assert(s.hex_digit_at(10) == 14);\n    assert(s.hex_digit_at(11) == 15);\n}\n\n#[test]\nfn test_to_uint() {\n    let s = String::new(\"20231219\");\n    assert(s.to_uint() == 20231219);\n}\n\n#[test]\nfn test_to_int() {\n    let s = String::new(\"-25\");\n    assert(s.to_int() == -25);\n\n    let s = String::new(\"25\");\n    assert(s.to_int() == 25);\n}\n\n#[test]\nfn test_to_uint_slice() {\n    let s = String::new(\"2023/12/19\");\n    assert(s.to_uint_slice(0, 4) == 2023);\n    assert(s.to_uint_slice(5, 7) == 12);\n    assert(s.to_uint_slice(8, 10) == 19);\n}\n\n#[test]\nfn test_from_hex_to_uint_slice() {\n    let s = String::new(\"0x1324ABCDEF\");\n    assert(s.from_hex_to_uint_slice(2, 6) == 0x1324);\n    assert(s.from_hex_to_uint_slice(6, 9) == 0xABC);\n    assert(s.from_hex_to_uint_slice(9, 12) == 0xDEF);\n}\n\n#[test]\nfn test_from_hex_to_uint() {\n    let uppercase_hex = String::new(\"0x1324ABCDEF\");\n    assert(uppercase_hex.from_hex_to_uint(true) == 0x1324ABCDEF);\n\n    let lowercase_hex = String::new(\"0x1234abcdef\");\n    assert(lowercase_hex.from_hex_to_uint(true) == 0x1234ABCDEF);\n\n    let hex_without_prefix = String::new(\"1234abcdef\");\n    assert(hex_without_prefix.from_hex_to_uint(false) == 0x1234ABCDEF);\n\n    let hex_with_leading_zeros = String::new(\"0x000001\");\n    assert(hex_with_leading_zeros.from_hex_to_uint(true) == 1);\n}\n\n#[test]\nfn test_to_array_of_chars() {\n    let s = String::new(\"hello\");\n    let arr = s.to_array_of_chars();\n    assert(arr[0] == \"h\");\n    assert(arr[1] == \"e\");\n    assert(arr[2] == \"l\");\n    assert(arr[3] == \"l\");\n    assert(arr[4] == \"o\");\n}\n\n// Tests for String trait\n#[test]\nfn test_trait_char_at() {\n    let s = \"hello\";\n    assert(s.char_at(0) == \"h\");\n    assert(s.char_at(1) == \"e\");\n    assert(s.char_at(2) == \"l\");\n    assert(s.char_at(3) == \"l\");\n    assert(s.char_at(4) == \"o\");\n}\n\n#[test]\nfn test_trait_code_at() {\n    let s = \"hello\";\n    assert(s.code_at(0) == 104);\n    assert(s.code_at(1) == 101);\n    assert(s.code_at(2) == 108);\n    assert(s.code_at(3) == 108);\n    assert(s.code_at(4) == 111);\n}\n\n#[test]\nfn test_trait_index_of() {\n    let s = \"hello\";\n    // Characters\n    assert(s.index_of(\"h\") == 0);\n    assert(s.index_of(\"e\") == 1);\n    assert(s.index_of(\"l\") == 2);\n    assert(s.index_of(\"o\") == 4);\n    assert(s.index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.index_of(\"he\") == 0);\n    assert(s.index_of(\"el\") == 1);\n    assert(s.index_of(\"ll\") == 2);\n    assert(s.index_of(\"lo\") == 3);\n    assert(s.index_of(\"hello\") == 0);\n    assert(s.index_of(\"ow\") == -1);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.index_of(\"some\") == 0);\n    assert(sentence.index_of(\"sentence\") == 5);\n    assert(sentence.index_of(\"with\") == 14);\n    assert(sentence.index_of(\"repetition\") == 24);\n    assert(sentence.index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.index_of(\"ti\") == 28);\n}\n\n#[test]\nfn test_trait_last_index_of() {\n    let s = \"hello\";\n    // Characters\n    assert(s.last_index_of(\"h\") == 0);\n    assert(s.last_index_of(\"e\") == 1);\n    assert(s.last_index_of(\"l\") == 3);\n    assert(s.last_index_of(\"o\") == 4);\n    assert(s.last_index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.last_index_of(\"he\") == 0);\n    assert(s.last_index_of(\"el\") == 1);\n    assert(s.last_index_of(\"ll\") == 2);\n    assert(s.last_index_of(\"lo\") == 3);\n    assert(s.last_index_of(\"hello\") == 0);\n    assert(s.last_index_of(\"ow\") == -1);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.last_index_of(\"some\") == 19);\n    assert(sentence.last_index_of(\"sentence\") == 5);\n    assert(sentence.last_index_of(\"with\") == 14);\n    assert(sentence.last_index_of(\"repetition\") == 24);\n    assert(sentence.last_index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.last_index_of(\"ti\") == 30);\n}\n\n#[test]\nfn test_trait_indexes_of() {\n    let s = \"hello\";\n    assert(s.indexes_of(\"h\").get(0) == 0);\n    assert(s.indexes_of(\"e\").get(0) == 1);\n    assert(s.indexes_of(\"l\").get(0) == 2);\n    assert(s.indexes_of(\"l\").get(1) == 3);\n    assert(s.indexes_of(\"o\").get(0) == 4);\n    assert(s.indexes_of(\"a\").len() == 0);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.indexes_of(\"some\").get(0) == 0);\n    assert(sentence.indexes_of(\"some\").get(1) == 19);\n    assert(sentence.indexes_of(\"sentence\").get(0) == 5);\n    assert(sentence.indexes_of(\"with\").get(0) == 14);\n    assert(sentence.indexes_of(\"repetition\").get(0) == 24);\n    assert(sentence.indexes_of(\"some sentence with some repetition\").get(0) == 0);\n    assert(sentence.indexes_of(\"ti\").get(0) == 28);\n    assert(sentence.indexes_of(\"ti\").get(1) == 30);\n    assert(sentence.indexes_of(\"a\").len() == 0);\n}\n\n#[test]\nfn test_trait_contains() {\n    let s = \"hello\";\n    assert(s.contains(\"h\"));\n    assert(s.contains(\"e\"));\n    assert(s.contains(\"l\"));\n    assert(s.contains(\"o\"));\n    assert(!s.contains(\"a\"));\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.contains(\"some\"));\n    assert(sentence.contains(\"sentence\"));\n    assert(sentence.contains(\"with\"));\n    assert(sentence.contains(\"repetition\"));\n    assert(sentence.contains(\"ti\"));\n    assert(!sentence.contains(\"hello\"));\n    assert(!sentence.contains(\"a\"));\n}\n\n#[test]\nfn test_trait_occurrences_of() {\n    let s = \"hello\";\n    assert(s.occurrences_of(\"h\") == 1);\n    assert(s.occurrences_of(\"e\") == 1);\n    assert(s.occurrences_of(\"l\") == 2);\n    assert(s.occurrences_of(\"o\") == 1);\n    assert(s.occurrences_of(\"a\") == 0);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.occurrences_of(\"some\") == 2);\n    assert(sentence.occurrences_of(\"sentence\") == 1);\n    assert(sentence.occurrences_of(\"with\") == 1);\n    assert(sentence.occurrences_of(\"repetition\") == 1);\n    assert(sentence.occurrences_of(\"ti\") == 2);\n    assert(sentence.occurrences_of(\"hello\") == 0);\n    assert(sentence.occurrences_of(\"a\") == 0);\n}\n\n#[test]\nfn test_trait_digit_at() {\n    let s = \"20231219\";\n    assert(s.digit_at(0) == 2);\n    assert(s.digit_at(1) == 0);\n    assert(s.digit_at(2) == 2);\n    assert(s.digit_at(3) == 3);\n    assert(s.digit_at(4) == 1);\n    assert(s.digit_at(5) == 2);\n    assert(s.digit_at(6) == 1);\n    assert(s.digit_at(7) == 9);\n}\n\n#[test]\nfn test_trait_hex_digit_at() {\n    let s = \"0x1324ABCDEF\";\n    assert(s.hex_digit_at(2) == 1);\n    assert(s.hex_digit_at(3) == 3);\n    assert(s.hex_digit_at(4) == 2);\n    assert(s.hex_digit_at(5) == 4);\n    assert(s.hex_digit_at(6) == 10);\n    assert(s.hex_digit_at(7) == 11);\n    assert(s.hex_digit_at(8) == 12);\n    assert(s.hex_digit_at(9) == 13);\n    assert(s.hex_digit_at(10) == 14);\n    assert(s.hex_digit_at(11) == 15);\n}\n\n#[test]\nfn test_trait_to_uint() {\n    let s = \"20231219\";\n    assert(s.to_uint() == 20231219);\n}\n\n#[test]\nfn test_trait_to_int() {\n    let s = \"-25\";\n    assert(s.to_int() == -25);\n\n    let s = \"25\";\n    assert(s.to_int() == 25);\n}\n\n#[test]\nfn test_trait_to_uint_slice() {\n    let s = \"2023/12/19\";\n    assert(s.to_uint_slice(0, 4) == 2023);\n    assert(s.to_uint_slice(5, 7) == 12);\n    assert(s.to_uint_slice(8, 10) == 19);\n}\n\n#[test]\nfn test_trait_from_hex_to_uint_slice() {\n    let s = \"0x1324ABCDEF\";\n    assert(s.from_hex_to_uint_slice(2, 6) == 0x1324);\n    assert(s.from_hex_to_uint_slice(6, 9) == 0xABC);\n    assert(s.from_hex_to_uint_slice(9, 12) == 0xDEF);\n}\n\n#[test]\nfn test_trait_from_hex_to_uint() {\n    let uppercase_hex = \"0x1324ABCDEF\";\n    assert(uppercase_hex.from_hex_to_uint(true) == 0x1324ABCDEF);\n\n    let lowercase_hex = \"0x1234abcdef\";\n    assert(lowercase_hex.from_hex_to_uint(true) == 0x1234ABCDEF);\n\n    let hex_without_prefix = \"1234abcdef\";\n    assert(hex_without_prefix.from_hex_to_uint(false) == 0x1234ABCDEF);\n\n    let hex_with_leading_zeros = \"0x000001\";\n    assert(hex_with_leading_zeros.from_hex_to_uint(true) == 1);\n}\n","path":"/home/maximilien/nargo/github.com/madztheo/noir-string-utils.gitmain/src/lib.nr"}},"names":["main"]}
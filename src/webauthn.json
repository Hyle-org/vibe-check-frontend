{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":1977180757583757549,"abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":46},"visibility":"public"},{"name":"tx_hash_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"tx_hash","type":{"kind":"array","length":43,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"program_outputs","type":{"kind":"struct","path":"ProgramOutputs","fields":[{"name":"authenticator_data","type":{"kind":"array","length":37,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"client_data_json_len","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"client_data_json","type":{"kind":"array","length":255,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"public"}],"param_witnesses":{"identity":[{"start":12,"end":58}],"identity_len":[{"start":11,"end":12}],"initial_state":[{"start":2,"end":6}],"initial_state_len":[{"start":1,"end":2}],"next_state":[{"start":7,"end":11}],"next_state_len":[{"start":6,"end":7}],"program_outputs":[{"start":102,"end":523}],"tx_hash":[{"start":59,"end":102}],"tx_hash_len":[{"start":58,"end":59}],"version":[{"start":0,"end":1}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"1":{"source":"use crate::cmp::Ord;\n\n// TODO: Once we fully move to the new SSA pass this module can be removed and replaced\n// by the methods in the `slice` module\nimpl<T, N> [T; N] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u64 {}\n\n    pub fn sort(self) -> Self where T: Ord {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        let sorted_index = self.get_sorting_index(ordering);\n        let mut result = self;\n        // Ensure the indexes are correct\n        for i in 0..N {\n            let pos = find_index(sorted_index, i);\n            assert(sorted_index[pos] == i);\n        }\n        // Sort the array using the indexes\n        for i in 0..N {\n            result[i] = self[sorted_index[i]];\n        }\n        // Ensure the array is sorted\n        for i in 0..N - 1 {\n            assert(ordering(result[i], result[i + 1]));\n        }\n\n        result\n    }\n\n    /// Returns the index of the elements in the array that would sort it, using the provided custom sorting function.\n    unconstrained fn get_sorting_index<Env>(self, ordering: fn[Env](T, T) -> bool) -> [u64; N] {\n        let mut result = [0; N];\n        let mut a = self;\n        for i in 0..N {\n            result[i] = i;\n        }\n        for i in 1..N {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                    let old_j = result[j];\n                    result[j] = result[i];\n                    result[i] = old_j;\n                }\n            }\n        }\n        result\n    }\n\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\n// helper function used to look up the position of a value in an array of Field\n// Note that function returns 0 if the value is not found\nunconstrained fn find_index<N>(a: [u64; N], find: u64) -> u64 {\n    let mut result = 0;\n    for i in 0..a.len() {\n        if a[i] == find {\n            result = i;\n        }\n    }\n    result\n}\n","path":"std/array.nr"},"46":{"source":"use dep::std;\n\npub fn prefix_sha256_hash<N>(prefix_length: u8, input: [u8; N]) -> [u8; 32] {\n    let mut result = [0; 32];\n    assert([1, 2, 3, 114, 134, 243].any(|x| x == prefix_length), \"Length is not supported\");\n    if prefix_length == 1 {\n        result = std::hash::sha256(prefix(input, [0; 1]));\n    }\n    if prefix_length == 2 {\n        result = std::hash::sha256(prefix(input, [0; 2]));\n    }\n    if prefix_length == 3 {\n        result = std::hash::sha256(prefix(input, [0; 3]));\n    }\n    if prefix_length == 114 {\n        result = std::hash::sha256(prefix(input, [0; 114]));\n    }\n    if prefix_length == 134 {\n        result = std::hash::sha256(prefix(input, [0; 134]));\n    }\n    if prefix_length == 243 {\n        result = std::hash::sha256(prefix(input, [0; 243]));\n    }\n    result\n}\n\n\npub fn concatenate_arrays(a: [u8; 37], b: [u8; 32]) -> [u8; 69] {\n    let mut result = [0; 69];\n    for i in 0..37 {\n        result[i] = a[i];\n    }\n    for i in 0..32 {\n        result[i+37] = b[i];\n    }\n    result\n}\n\npub fn verify_identity(pub_key_x: [u8; 32], pub_key_y: [u8; 32], identity: str<46>) {\n    // Compute the publickey as concatenation of pub_key_x and pub_key_y\n    let mut pub_key = [0; 64];\n    for i in 0..32 {\n        pub_key[i] = pub_key_x[i];\n    }\n    for j in 0..32 {\n        pub_key[j+32] = pub_key_y[j];\n    }\n    // Compute the address as the hash of the publickey\n    let address: [u8; 32] = std::hash::sha256(pub_key);\n\n    // identity is the last 20bytes of the address.\n    // Assert that there is a match between identity provided and identity computed from pubkeys\n    for k in 0..20 {\n        assert(address[12 + k] == identity.from_hex_to_uint_slice(2*k, 2*k + 2) as u8);\n    }\n}\n\n\nfn prefix<N, M>(input: [u8; N], mut result: [u8; M]) -> [u8; M] {\n    for i in 0..M {\n        result[i] = input[i];\n    }\n    result\n}","path":"/home/maximilien/cairo-erc20-runner/noir-webauthn/src/utils.nr"},"47":{"source":"mod utils;\n\nuse dep::std;\nuse dep::std::println;\nuse crate::utils::{prefix_sha256_hash, concatenate_arrays, verify_identity};\n\nglobal CLIENT_DATA_JSON_LEN = 255;\n\nstruct ProgramOutputs {\n    authenticator_data: [u8; 37],\n    client_data_json_len: u8,\n    client_data_json: [u8; CLIENT_DATA_JSON_LEN],\n    signature: [u8; 64],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n}\n\n\nfn main(\n    version: pub u32,\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    identity_len: pub u8,\n    identity: pub str<46>,\n    tx_hash_len: pub u32,\n    tx_hash: pub [u8; 43],\n    program_outputs: pub ProgramOutputs\n) {\n    let client_data_json_hash = prefix_sha256_hash(program_outputs.client_data_json_len, program_outputs.client_data_json);\n    let concat = concatenate_arrays(program_outputs.authenticator_data, client_data_json_hash);\n    let hashed_data = std::hash::sha256(concat);\n\n    // Verifying pub_key matches the identity\n    verify_identity(program_outputs.pub_key_x, program_outputs.pub_key_y, identity);\n\n\n    // The txhash IS the challenge\n    for i in 0..(tx_hash.len()) {\n        assert(tx_hash[i] == program_outputs.client_data_json[36 + i]);\n    }\n\n    let valid_signature = std::ecdsa_secp256r1::verify_signature(program_outputs.pub_key_x, program_outputs.pub_key_y, program_outputs.signature, hashed_data);\n    \n    assert(valid_signature);\n    assert(tx_hash_len == 43);\n    assert(identity_len == 46);\n}\n\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_134() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,125,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // Padding with 121 zeros (134+121 = 255) \n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0\n    ];\n    let signature = [80,114,197,245,128,150,206,160,135,105,51,205,42,143,25,53,119,97,166,196,95,98,53,63,168,171,63,85,41,42,196,134,26,198,126,179,109,99,41,92,86,45,240,238,196,106,77,219,146,196,183,80,225,170,66,218,169,244,230,252,61,213,29,201];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [201,91,99,172,65,154,80,154,189,195,194,210,62,219,224,36,43,134,143,236,137,178,121,35,112,146,103,238,37,100,145,26];\n    let pub_key_y = [169,8,63,83,58,93,192,39,114,115,138,176,56,254,162,127,93,19,156,93,51,9,194,161,253,10,203,128,171,254,255,83];\n\n    let program_outputs = ProgramOutputs {\n            authenticator_data,\n            client_data_json_len: 134,\n            client_data_json,\n            signature,\n            pub_key_x,\n            pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 1;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 1;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 46;\n    let identity = \"c59b18d3bdaccb4d689048559a9bb6e8265293bf.ecdsa\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        program_outputs,\n    );\n}\n\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_243() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,44,34,111,116,104,101,114,95,107,101,121,115,95,99,97,110,95,98,101,95,97,100,100,101,100,95,104,101,114,101,34,58,34,100,111,32,110,111,116,32,99,111,109,112,97,114,101,32,99,108,105,101,110,116,68,97,116,97,74,83,79,78,32,97,103,97,105,110,115,116,32,97,32,116,101,109,112,108,97,116,101,46,32,83,101,101,32,104,116,116,112,115,58,47,47,103,111,111,46,103,108,47,121,97,98,80,101,120,34,125,\n        0,0,0,0,0,0,0,0,0,0,0,0 // Padding with 12 zeros (243+12 = 255) \n    ];\n    let signature = [35,9,110,138,212,71,172,124,13,7,194,158,153,63,87,67,67,25,22,122,101,253,159,175,106,50,52,157,164,70,148,46,126,152,146,190,137,37,199,95,249,115,198,94,237,198,18,23,200,185,52,157,189,205,144,63,212,29,177,20,24,255,160,127];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [15,206,241,12,21,160,54,11,79,72,44,109,43,45,101,54,210,243,13,236,51,33,47,66,187,38,60,249,64,70,37,252];\n    let pub_key_y = [43,221,114,86,240,184,224,51,237,41,173,85,147,130,225,150,159,150,44,23,57,92,82,37,27,40,69,123,252,224,3,197];\n    \n    let program_outputs = ProgramOutputs {\n        authenticator_data,\n        client_data_json_len: 243,\n        client_data_json,\n        signature,\n        pub_key_x,\n        pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 1;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 1;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 46;\n    let identity = \"3f368bf90c71946fc7b0cde9161ace42985d235f.ecdsa\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        program_outputs,\n    );\n}\n\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_243_bis() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,44,34,111,116,104,101,114,95,107,101,121,115,95,99,97,110,95,98,101,95,97,100,100,101,100,95,104,101,114,101,34,58,34,100,111,32,110,111,116,32,99,111,109,112,97,114,101,32,99,108,105,101,110,116,68,97,116,97,74,83,79,78,32,97,103,97,105,110,115,116,32,97,32,116,101,109,112,108,97,116,101,46,32,83,101,101,32,104,116,116,112,115,58,47,47,103,111,111,46,103,108,47,121,97,98,80,101,120,34,125,\n        0,0,0,0,0,0,0,0,0,0,0,0 // Padding with 12 zeros (243+12 = 255) \n    ];\n    let signature = [216,184,64,61,79,81,150,39,72,191,167,234,52,253,225,66,52,192,76,159,65,164,134,34,212,255,104,99,14,53,71,115,0,190,96,135,49,186,213,189,93,36,212,143,36,92,27,42,44,103,95,153,46,59,158,22,223,196,84,102,51,209,135,233];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [35,250,194,235,47,86,159,70,36,137,145,195,83,245,203,137,12,28,43,171,167,226,44,90,199,107,235,0,229,229,133,67];\n    let pub_key_y = [84,107,152,100,72,140,98,57,186,30,76,187,129,194,209,158,96,37,254,211,60,198,27,227,167,247,204,51,145,53,120,95];\n\n    let program_outputs = ProgramOutputs {\n        authenticator_data,\n        client_data_json_len: 243,\n        client_data_json,\n        signature,\n        pub_key_x,\n        pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 1;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 1;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 46;\n    let identity = \"ae0e5100ea7d28905ce690194c0717cd93756a20.ecdsa\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        program_outputs,\n    );\n}\n","path":"/home/maximilien/cairo-erc20-runner/noir-webauthn/src/main.nr"},"48":{"source":"use dep::std::println;\n\nglobal UPPERCASE_A_INDEX: u8 = 65;\nglobal UPPERCASE_Z_INDEX: u8 = 90;\nglobal LOWERCASE_A_INDEX: u8 = 97;\nglobal LOWERCASE_Z_INDEX: u8 = 122;\nglobal ZERO_INDEX: u8 = 48;\nglobal NINE_INDEX: u8 = 57;\nglobal ASCII_TABLE_START_INDEX: u8 = 0;\nglobal SORTED_ASCII_TABLE: [str<1>; 127] = [    \n    \"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\t\",\"\\n\",\"\\0\",\"\\0\",\"\\r\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\n    \" \",\"!\",\"\\\"\",\"#\",\"$\",\"%\",\"&\",\"'\",\"(\",\")\",\"*\",\"+\",\",\",\"-\",\".\",\"/\",\n    \"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\n    \":\",\";\",\"<\",\"=\",\">\",\"?\",\"@\",\n    \"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\",\n    \"[\",\"\\\\\",\"]\",\"^\",\"_\",\"`\",\n    \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\n    \"{\",\"|\",\"}\",\"~\"\n];\n\n// Functions \nfn code_at<N>(s: str<N>, index: u64) -> u8 {\n    assert(index < N);\n    s.as_bytes()[index]\n}\n\nfn char_at<N>(s: str<N>, index: u64) -> str<1> {\n    let byte = code_at(s, index);\n    let ascii_index = byte - ASCII_TABLE_START_INDEX;\n    SORTED_ASCII_TABLE[ascii_index]\n}\n\nfn index_of<N, M>(s: str<N>, substr: str<M>) -> i64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    for i in 0..N {\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            index = i as i64;\n            match_count += 1;\n        } else if (index != -1) & (i - index < M) {\n            if (str_bytes[i] != substr_bytes[i - index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    // If the match count is not equal to the length of the substring,\n    // then the substring is not in the string\n    // Can happen when looking at a substring that is at the end of the string\n    // but the match is only partial\n    if match_count != M {\n        index = -1;\n    }\n\n    index\n}\n\nfn last_index_of<N, M>(s: str<N>, substr: str<M>) -> i64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    let mut final_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    for i in 0..N {\n        if (match_count == M) {\n            final_index = temp_index;\n            temp_index = -1;\n            match_count = 0;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        final_index = temp_index;\n    }\n\n    final_index\n}\n\n// We use Field instead of integers for the Vector here as integers \n// don't seem to work well with Vectors at the moment\nfn indexes_of<N, M>(s: str<N>, substr: str<M>) -> Vec<Field> {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    let mut indexes: Vec<Field> = Vec::new();\n    for i in 0..N {\n        if (match_count == M) {\n            indexes.push(temp_index as Field);\n            temp_index = -1;\n            match_count = 0;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        indexes.push(temp_index as Field);\n    }\n\n    indexes\n}\n\nfn contains<N, M>(s: str<N>, substr: str<M>) -> bool {\n    index_of(s, substr) != -1\n}\n\nfn occurrences_of<N, M>(s: str<N>, substr: str<M>) -> u64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    let mut occurrences = 0;\n    for i in 0..N {\n        if (match_count == M) {\n            temp_index = -1;\n            match_count = 0;\n            occurrences += 1;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        occurrences += 1;\n    }\n\n    occurrences\n}\n\nfn digit_at<N>(s: str<N>, index: u64) -> u8 {\n    let byte = s.as_bytes()[index];\n    assert((byte >= ZERO_INDEX) & (byte <= NINE_INDEX), \"Character is not a digit\");\n    byte - ZERO_INDEX\n}\n\nfn hex_digit_at<N>(s: str<N>, index: u64) -> u8 {\n    let byte = s.as_bytes()[index];\n    if (byte >= ZERO_INDEX) & (byte <= NINE_INDEX) {\n        byte - ZERO_INDEX\n    } else if (byte >= UPPERCASE_A_INDEX) & (byte <= UPPERCASE_Z_INDEX) {\n        byte - UPPERCASE_A_INDEX + 10\n    } else if (byte >= LOWERCASE_A_INDEX) & (byte <= LOWERCASE_Z_INDEX) {\n        byte - LOWERCASE_A_INDEX + 10\n    } else {\n        assert(false, \"Character is not a hex digit\");\n        0\n    }\n}\n\nfn to_uint_slice<N>(s: str<N>, start: u64, end: u64) -> u64 {\n    let mut result = 0;\n    for i in start..end {\n        let digit = digit_at(s, i);\n        result = result * 10 + digit as u64;\n    }\n    result\n}\n\nfn to_uint<N>(s: str<N>) -> u64 {\n    to_uint_slice(s, 0, N)\n}\n\nfn to_int<N>(s: str<N>) -> i64 {\n    if char_at(s, 0) == \"-\" {\n        -1 * to_uint_slice(s, 1, N) as i64\n    } else {\n        to_uint_slice(s, 0, N) as i64\n    }\n}\n\nfn from_hex_to_uint_slice<N>(s: str<N>, start: u64, end: u64) -> u64 {\n    let mut result = 0;\n    for i in start..end {\n        let digit = hex_digit_at(s, i);\n        result = result * 16 + digit as u64;\n    }\n    result\n}\n\nfn from_hex_to_uint<N>(s: str<N>, with_prefix: bool) -> u64 {\n    if with_prefix {\n        from_hex_to_uint_slice(s, 2, N)\n    } else {\n        from_hex_to_uint_slice(s, 0, N)\n    }\n}\n\nfn to_array_of_chars<N>(s: str<N>) -> [str<1>; N] {\n    let mut result: [str<1>; N] = [\" \"; N];\n    for i in 0..N {\n        result[i] = char_at(s, i);\n    }\n    result\n}\n\n// Struct\n\nstruct String<N> {\n    value: str<N>,\n    len: u64,\n}\n\n// Implementation over String struct\n\nimpl<N> String<N> {\n    fn new(value: str<N>) -> Self {\n        Self { value, len: N }\n    }\n\n    fn code_at(self: Self, index: u64) -> u8 {\n        code_at(self.value, index)\n    }\n\n    fn char_at(self: Self, index: u64) -> str<1> {\n        char_at(self.value, index)\n    }\n\n    fn index_of<M>(self: Self, substr: str<M>) -> i64 {\n        index_of(self.value, substr)\n    }\n\n    fn last_index_of<M>(self: Self, substr: str<M>) -> i64 {\n        last_index_of(self.value, substr)\n    }\n\n    fn indexes_of<M>(self: Self, substr: str<M>) -> Vec<Field> {\n        indexes_of(self.value, substr)\n    }\n\n    fn contains<M>(self: Self, substr: str<M>) -> bool {\n        contains(self.value, substr)\n    }\n\n    fn occurrences_of<M>(self: Self, substr: str<M>) -> u64 {\n        occurrences_of(self.value, substr)\n    }\n\n    fn digit_at(self: Self, index: u64) -> u8 {\n        digit_at(self.value, index)\n    }\n\n    fn hex_digit_at(self: Self, index: u64) -> u8 {\n        hex_digit_at(self.value, index)\n    }\n\n    fn to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        to_uint_slice(self.value, start, end)\n    }\n\n    fn to_uint(self: Self) -> u64 {\n        to_uint_slice(self.value, 0, self.len)\n    }\n\n    fn to_int(self: Self) -> i64 {\n        to_int(self.value)\n    }\n\n    fn from_hex_to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        from_hex_to_uint_slice(self.value, start, end)\n    }\n\n    fn from_hex_to_uint(self: Self, with_prefix: bool) -> u64 {\n        from_hex_to_uint(self.value, with_prefix)\n    }\n\n    fn to_array_of_chars(self: Self) -> [str<1>; N] {\n        to_array_of_chars(self.value)\n    }\n}\n\n// Trait\ntrait StringTrait {\n    fn code_at(self, index: u64) -> u8;\n    fn char_at(self, index: u64) -> str<1>;\n    fn index_of<M>(self, substr: str<M>) -> i64;\n    fn last_index_of<M>(self, c: str<M>) -> i64;\n    fn indexes_of<M>(self, c: str<M>) -> Vec<Field>;\n    fn contains<M>(self, substr: str<M>) -> bool;\n    fn occurrences_of<M>(self, c: str<M>) -> u64;\n    fn digit_at(self, index: u64) -> u8;\n    fn hex_digit_at(self, index: u64) -> u8;\n    fn to_uint_slice(self, start: u64, end: u64) -> u64;\n    fn to_uint(self) -> u64;\n    fn to_int(self) -> i64;\n    fn from_hex_to_uint_slice(self, start: u64, end: u64) -> u64;\n    fn from_hex_to_uint(self, with_prefix: bool) -> u64;\n}\n\n// Implementation for str type\nimpl<N> StringTrait for str<N> {\n    fn code_at(self: Self, index: u64) -> u8 {\n        code_at(self, index)\n    }\n\n    fn char_at(self: Self, index: u64) -> str<1> {\n        char_at(self, index)\n    }\n\n    fn index_of<M>(self: Self, substr: str<M>) -> i64 {\n        index_of(self, substr)\n    }\n\n    fn last_index_of<M>(self: Self, substr: str<M>) -> i64 {\n        last_index_of(self, substr)\n    }\n\n    fn indexes_of<M>(self: Self, substr: str<M>) -> Vec<Field> {\n        indexes_of(self, substr)\n    }\n\n    fn contains<M>(self: Self, substr: str<M>) -> bool {\n        contains(self, substr)\n    }\n\n    fn occurrences_of<M>(self: Self, substr: str<M>) -> u64 {\n        occurrences_of(self, substr)\n    }\n\n    fn digit_at(self: Self, index: u64) -> u8 {\n        digit_at(self, index)\n    }\n\n    fn hex_digit_at(self: Self, index: u64) -> u8 {\n        hex_digit_at(self, index)\n    }\n\n    fn to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        to_uint_slice(self, start, end)\n    }\n\n    fn to_uint(self: Self) -> u64 {\n        to_uint_slice(self, 0, N)\n    }\n\n    fn to_int(self: Self) -> i64 {\n        to_int(self)\n    }\n\n    fn from_hex_to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        from_hex_to_uint_slice(self, start, end)\n    }\n\n    fn from_hex_to_uint(self: Self, with_prefix: bool) -> u64 {\n        from_hex_to_uint(self, with_prefix)\n    }\n}\n\n// Tests for String struct\n#[test]\nfn test_init() {\n    let s = String::new(\"hello\");\n    assert(s.len == 5);\n    assert(s.value == \"hello\");\n}\n\n#[test]\nfn test_char_at() {\n    let s = String::new(\"hello\");\n    assert(s.char_at(0) == \"h\");\n    assert(s.char_at(1) == \"e\");\n    assert(s.char_at(2) == \"l\");\n    assert(s.char_at(3) == \"l\");\n    assert(s.char_at(4) == \"o\");\n}\n\n#[test]\nfn test_code_at() {\n    let s = String::new(\"hello\");\n    assert(s.code_at(0) == 104);\n    assert(s.code_at(1) == 101);\n    assert(s.code_at(2) == 108);\n    assert(s.code_at(3) == 108);\n    assert(s.code_at(4) == 111);\n}\n\n#[test]\nfn test_index_of() {\n    let s = String::new(\"hello\");\n    // Characters\n    assert(s.index_of(\"h\") == 0);\n    assert(s.index_of(\"e\") == 1);\n    assert(s.index_of(\"l\") == 2);\n    assert(s.index_of(\"o\") == 4);\n    assert(s.index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.index_of(\"he\") == 0);\n    assert(s.index_of(\"el\") == 1);\n    assert(s.index_of(\"ll\") == 2);\n    assert(s.index_of(\"lo\") == 3);\n    assert(s.index_of(\"hello\") == 0);\n    assert(s.index_of(\"ow\") == -1);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.index_of(\"some\") == 0);\n    assert(sentence.index_of(\"sentence\") == 5);\n    assert(sentence.index_of(\"with\") == 14);\n    assert(sentence.index_of(\"repetition\") == 24);\n    assert(sentence.index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.index_of(\"ti\") == 28);\n}\n\n#[test]\nfn test_last_index_of() {\n    let s = String::new(\"hello\");\n    assert(s.last_index_of(\"h\") == 0);\n    assert(s.last_index_of(\"e\") == 1);\n    assert(s.last_index_of(\"l\") == 3);\n    assert(s.last_index_of(\"o\") == 4);\n    assert(s.last_index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.last_index_of(\"he\") == 0);\n    assert(s.last_index_of(\"el\") == 1);\n    assert(s.last_index_of(\"ll\") == 2);\n    assert(s.last_index_of(\"lo\") == 3);\n    assert(s.last_index_of(\"hello\") == 0);\n    assert(s.last_index_of(\"ow\") == -1);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.last_index_of(\"some\") == 19);\n    assert(sentence.last_index_of(\"sentence\") == 5);\n    assert(sentence.last_index_of(\"with\") == 14);\n    assert(sentence.last_index_of(\"repetition\") == 24);\n    assert(sentence.last_index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.last_index_of(\"ti\") == 30);\n}\n\n#[test]\nfn test_indexes_of() {\n    let s = String::new(\"hello\");\n    assert(s.indexes_of(\"h\").get(0) == 0);\n    assert(s.indexes_of(\"e\").get(0) == 1);\n    assert(s.indexes_of(\"l\").get(0) == 2);\n    assert(s.indexes_of(\"l\").get(1) == 3);\n    assert(s.indexes_of(\"o\").get(0) == 4);\n    assert(s.indexes_of(\"a\").len() == 0);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.indexes_of(\"some\").get(0) == 0);\n    assert(sentence.indexes_of(\"some\").get(1) == 19);\n    assert(sentence.indexes_of(\"sentence\").get(0) == 5);\n    assert(sentence.indexes_of(\"with\").get(0) == 14);\n    assert(sentence.indexes_of(\"repetition\").get(0) == 24);\n    assert(sentence.indexes_of(\"some sentence with some repetition\").get(0) == 0);\n    assert(sentence.indexes_of(\"ti\").get(0) == 28);\n    assert(sentence.indexes_of(\"ti\").get(1) == 30);\n    assert(sentence.indexes_of(\"a\").len() == 0);\n}\n\n#[test]\nfn test_contains() {\n    let s = String::new(\"hello\");\n    assert(s.contains(\"h\"));\n    assert(s.contains(\"e\"));\n    assert(s.contains(\"l\"));\n    assert(s.contains(\"o\"));\n    assert(!s.contains(\"a\"));\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.contains(\"some\"));\n    assert(sentence.contains(\"sentence\"));\n    assert(sentence.contains(\"with\"));\n    assert(sentence.contains(\"repetition\"));\n    assert(sentence.contains(\"ti\"));\n    assert(!sentence.contains(\"hello\"));\n    assert(!sentence.contains(\"a\"));\n}\n\n#[test]\nfn test_occurrences_of() {\n    let s = String::new(\"hello\");\n    assert(s.occurrences_of(\"h\") == 1);\n    assert(s.occurrences_of(\"e\") == 1);\n    assert(s.occurrences_of(\"l\") == 2);\n    assert(s.occurrences_of(\"o\") == 1);\n    assert(s.occurrences_of(\"a\") == 0);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.occurrences_of(\"some\") == 2);\n    assert(sentence.occurrences_of(\"sentence\") == 1);\n    assert(sentence.occurrences_of(\"with\") == 1);\n    assert(sentence.occurrences_of(\"repetition\") == 1);\n    assert(sentence.occurrences_of(\"ti\") == 2);\n    assert(sentence.occurrences_of(\"hello\") == 0);\n    assert(sentence.occurrences_of(\"a\") == 0);\n}\n\n#[test]\nfn test_digit_at() {\n    let s = String::new(\"20231219\");\n    assert(s.digit_at(0) == 2);\n    assert(s.digit_at(1) == 0);\n    assert(s.digit_at(2) == 2);\n    assert(s.digit_at(3) == 3);\n    assert(s.digit_at(4) == 1);\n    assert(s.digit_at(5) == 2);\n    assert(s.digit_at(6) == 1);\n    assert(s.digit_at(7) == 9);\n}\n\n#[test]\nfn test_hex_digit_at() {\n    let s = String::new(\"0x1324ABCDEF\");\n    assert(s.hex_digit_at(2) == 1);\n    assert(s.hex_digit_at(3) == 3);\n    assert(s.hex_digit_at(4) == 2);\n    assert(s.hex_digit_at(5) == 4);\n    assert(s.hex_digit_at(6) == 10);\n    assert(s.hex_digit_at(7) == 11);\n    assert(s.hex_digit_at(8) == 12);\n    assert(s.hex_digit_at(9) == 13);\n    assert(s.hex_digit_at(10) == 14);\n    assert(s.hex_digit_at(11) == 15);\n}\n\n#[test]\nfn test_to_uint() {\n    let s = String::new(\"20231219\");\n    assert(s.to_uint() == 20231219);\n}\n\n#[test]\nfn test_to_int() {\n    let s = String::new(\"-25\");\n    assert(s.to_int() == -25);\n\n    let s = String::new(\"25\");\n    assert(s.to_int() == 25);\n}\n\n#[test]\nfn test_to_uint_slice() {\n    let s = String::new(\"2023/12/19\");\n    assert(s.to_uint_slice(0, 4) == 2023);\n    assert(s.to_uint_slice(5, 7) == 12);\n    assert(s.to_uint_slice(8, 10) == 19);\n}\n\n#[test]\nfn test_from_hex_to_uint_slice() {\n    let s = String::new(\"0x1324ABCDEF\");\n    assert(s.from_hex_to_uint_slice(2, 6) == 0x1324);\n    assert(s.from_hex_to_uint_slice(6, 9) == 0xABC);\n    assert(s.from_hex_to_uint_slice(9, 12) == 0xDEF);\n}\n\n#[test]\nfn test_from_hex_to_uint() {\n    let uppercase_hex = String::new(\"0x1324ABCDEF\");\n    assert(uppercase_hex.from_hex_to_uint(true) == 0x1324ABCDEF);\n\n    let lowercase_hex = String::new(\"0x1234abcdef\");\n    assert(lowercase_hex.from_hex_to_uint(true) == 0x1234ABCDEF);\n\n    let hex_without_prefix = String::new(\"1234abcdef\");\n    assert(hex_without_prefix.from_hex_to_uint(false) == 0x1234ABCDEF);\n\n    let hex_with_leading_zeros = String::new(\"0x000001\");\n    assert(hex_with_leading_zeros.from_hex_to_uint(true) == 1);\n}\n\n#[test]\nfn test_to_array_of_chars() {\n    let s = String::new(\"hello\");\n    let arr = s.to_array_of_chars();\n    assert(arr[0] == \"h\");\n    assert(arr[1] == \"e\");\n    assert(arr[2] == \"l\");\n    assert(arr[3] == \"l\");\n    assert(arr[4] == \"o\");\n}\n\n// Tests for String trait\n#[test]\nfn test_trait_char_at() {\n    let s = \"hello\";\n    assert(s.char_at(0) == \"h\");\n    assert(s.char_at(1) == \"e\");\n    assert(s.char_at(2) == \"l\");\n    assert(s.char_at(3) == \"l\");\n    assert(s.char_at(4) == \"o\");\n}\n\n#[test]\nfn test_trait_code_at() {\n    let s = \"hello\";\n    assert(s.code_at(0) == 104);\n    assert(s.code_at(1) == 101);\n    assert(s.code_at(2) == 108);\n    assert(s.code_at(3) == 108);\n    assert(s.code_at(4) == 111);\n}\n\n#[test]\nfn test_trait_index_of() {\n    let s = \"hello\";\n    // Characters\n    assert(s.index_of(\"h\") == 0);\n    assert(s.index_of(\"e\") == 1);\n    assert(s.index_of(\"l\") == 2);\n    assert(s.index_of(\"o\") == 4);\n    assert(s.index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.index_of(\"he\") == 0);\n    assert(s.index_of(\"el\") == 1);\n    assert(s.index_of(\"ll\") == 2);\n    assert(s.index_of(\"lo\") == 3);\n    assert(s.index_of(\"hello\") == 0);\n    assert(s.index_of(\"ow\") == -1);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.index_of(\"some\") == 0);\n    assert(sentence.index_of(\"sentence\") == 5);\n    assert(sentence.index_of(\"with\") == 14);\n    assert(sentence.index_of(\"repetition\") == 24);\n    assert(sentence.index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.index_of(\"ti\") == 28);\n}\n\n#[test]\nfn test_trait_last_index_of() {\n    let s = \"hello\";\n    // Characters\n    assert(s.last_index_of(\"h\") == 0);\n    assert(s.last_index_of(\"e\") == 1);\n    assert(s.last_index_of(\"l\") == 3);\n    assert(s.last_index_of(\"o\") == 4);\n    assert(s.last_index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.last_index_of(\"he\") == 0);\n    assert(s.last_index_of(\"el\") == 1);\n    assert(s.last_index_of(\"ll\") == 2);\n    assert(s.last_index_of(\"lo\") == 3);\n    assert(s.last_index_of(\"hello\") == 0);\n    assert(s.last_index_of(\"ow\") == -1);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.last_index_of(\"some\") == 19);\n    assert(sentence.last_index_of(\"sentence\") == 5);\n    assert(sentence.last_index_of(\"with\") == 14);\n    assert(sentence.last_index_of(\"repetition\") == 24);\n    assert(sentence.last_index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.last_index_of(\"ti\") == 30);\n}\n\n#[test]\nfn test_trait_indexes_of() {\n    let s = \"hello\";\n    assert(s.indexes_of(\"h\").get(0) == 0);\n    assert(s.indexes_of(\"e\").get(0) == 1);\n    assert(s.indexes_of(\"l\").get(0) == 2);\n    assert(s.indexes_of(\"l\").get(1) == 3);\n    assert(s.indexes_of(\"o\").get(0) == 4);\n    assert(s.indexes_of(\"a\").len() == 0);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.indexes_of(\"some\").get(0) == 0);\n    assert(sentence.indexes_of(\"some\").get(1) == 19);\n    assert(sentence.indexes_of(\"sentence\").get(0) == 5);\n    assert(sentence.indexes_of(\"with\").get(0) == 14);\n    assert(sentence.indexes_of(\"repetition\").get(0) == 24);\n    assert(sentence.indexes_of(\"some sentence with some repetition\").get(0) == 0);\n    assert(sentence.indexes_of(\"ti\").get(0) == 28);\n    assert(sentence.indexes_of(\"ti\").get(1) == 30);\n    assert(sentence.indexes_of(\"a\").len() == 0);\n}\n\n#[test]\nfn test_trait_contains() {\n    let s = \"hello\";\n    assert(s.contains(\"h\"));\n    assert(s.contains(\"e\"));\n    assert(s.contains(\"l\"));\n    assert(s.contains(\"o\"));\n    assert(!s.contains(\"a\"));\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.contains(\"some\"));\n    assert(sentence.contains(\"sentence\"));\n    assert(sentence.contains(\"with\"));\n    assert(sentence.contains(\"repetition\"));\n    assert(sentence.contains(\"ti\"));\n    assert(!sentence.contains(\"hello\"));\n    assert(!sentence.contains(\"a\"));\n}\n\n#[test]\nfn test_trait_occurrences_of() {\n    let s = \"hello\";\n    assert(s.occurrences_of(\"h\") == 1);\n    assert(s.occurrences_of(\"e\") == 1);\n    assert(s.occurrences_of(\"l\") == 2);\n    assert(s.occurrences_of(\"o\") == 1);\n    assert(s.occurrences_of(\"a\") == 0);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.occurrences_of(\"some\") == 2);\n    assert(sentence.occurrences_of(\"sentence\") == 1);\n    assert(sentence.occurrences_of(\"with\") == 1);\n    assert(sentence.occurrences_of(\"repetition\") == 1);\n    assert(sentence.occurrences_of(\"ti\") == 2);\n    assert(sentence.occurrences_of(\"hello\") == 0);\n    assert(sentence.occurrences_of(\"a\") == 0);\n}\n\n#[test]\nfn test_trait_digit_at() {\n    let s = \"20231219\";\n    assert(s.digit_at(0) == 2);\n    assert(s.digit_at(1) == 0);\n    assert(s.digit_at(2) == 2);\n    assert(s.digit_at(3) == 3);\n    assert(s.digit_at(4) == 1);\n    assert(s.digit_at(5) == 2);\n    assert(s.digit_at(6) == 1);\n    assert(s.digit_at(7) == 9);\n}\n\n#[test]\nfn test_trait_hex_digit_at() {\n    let s = \"0x1324ABCDEF\";\n    assert(s.hex_digit_at(2) == 1);\n    assert(s.hex_digit_at(3) == 3);\n    assert(s.hex_digit_at(4) == 2);\n    assert(s.hex_digit_at(5) == 4);\n    assert(s.hex_digit_at(6) == 10);\n    assert(s.hex_digit_at(7) == 11);\n    assert(s.hex_digit_at(8) == 12);\n    assert(s.hex_digit_at(9) == 13);\n    assert(s.hex_digit_at(10) == 14);\n    assert(s.hex_digit_at(11) == 15);\n}\n\n#[test]\nfn test_trait_to_uint() {\n    let s = \"20231219\";\n    assert(s.to_uint() == 20231219);\n}\n\n#[test]\nfn test_trait_to_int() {\n    let s = \"-25\";\n    assert(s.to_int() == -25);\n\n    let s = \"25\";\n    assert(s.to_int() == 25);\n}\n\n#[test]\nfn test_trait_to_uint_slice() {\n    let s = \"2023/12/19\";\n    assert(s.to_uint_slice(0, 4) == 2023);\n    assert(s.to_uint_slice(5, 7) == 12);\n    assert(s.to_uint_slice(8, 10) == 19);\n}\n\n#[test]\nfn test_trait_from_hex_to_uint_slice() {\n    let s = \"0x1324ABCDEF\";\n    assert(s.from_hex_to_uint_slice(2, 6) == 0x1324);\n    assert(s.from_hex_to_uint_slice(6, 9) == 0xABC);\n    assert(s.from_hex_to_uint_slice(9, 12) == 0xDEF);\n}\n\n#[test]\nfn test_trait_from_hex_to_uint() {\n    let uppercase_hex = \"0x1324ABCDEF\";\n    assert(uppercase_hex.from_hex_to_uint(true) == 0x1324ABCDEF);\n\n    let lowercase_hex = \"0x1234abcdef\";\n    assert(lowercase_hex.from_hex_to_uint(true) == 0x1234ABCDEF);\n\n    let hex_without_prefix = \"1234abcdef\";\n    assert(hex_without_prefix.from_hex_to_uint(false) == 0x1234ABCDEF);\n\n    let hex_with_leading_zeros = \"0x000001\";\n    assert(hex_with_leading_zeros.from_hex_to_uint(true) == 1);\n}\n","path":"/home/maximilien/nargo/github.com/madztheo/noir-string-utils.gitmain/src/lib.nr"}},"names":["main"]}
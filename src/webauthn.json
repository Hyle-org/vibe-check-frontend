{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":14065966592846548182,"abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":40},"visibility":"public"},{"name":"tx_hash_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"tx_hash","type":{"kind":"array","length":43,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"program_outputs","type":{"kind":"struct","path":"ProgramOutputs","fields":[{"name":"authenticator_data","type":{"kind":"array","length":37,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"client_data_json_len","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"client_data_json","type":{"kind":"array","length":255,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"public"}],"param_witnesses":{"identity":[{"start":12,"end":52}],"identity_len":[{"start":11,"end":12}],"initial_state":[{"start":2,"end":6}],"initial_state_len":[{"start":1,"end":2}],"next_state":[{"start":7,"end":11}],"next_state_len":[{"start":6,"end":7}],"program_outputs":[{"start":96,"end":517}],"tx_hash":[{"start":53,"end":96}],"tx_hash_len":[{"start":52,"end":53}],"version":[{"start":0,"end":1}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"1":{"source":"use crate::cmp::Ord;\n\n// TODO: Once we fully move to the new SSA pass this module can be removed and replaced\n// by the methods in the `slice` module\nimpl<T, N> [T; N] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u64 {}\n\n    pub fn sort(self) -> Self where T: Ord {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        let sorted_index = self.get_sorting_index(ordering);\n        let mut result = self;\n        // Ensure the indexes are correct\n        for i in 0..N {\n            let pos = find_index(sorted_index, i);\n            assert(sorted_index[pos] == i);\n        }\n        // Sort the array using the indexes\n        for i in 0..N {\n            result[i] = self[sorted_index[i]];\n        }\n        // Ensure the array is sorted\n        for i in 0..N - 1 {\n            assert(ordering(result[i], result[i + 1]));\n        }\n\n        result\n    }\n\n    /// Returns the index of the elements in the array that would sort it, using the provided custom sorting function.\n    unconstrained fn get_sorting_index<Env>(self, ordering: fn[Env](T, T) -> bool) -> [u64; N] {\n        let mut result = [0; N];\n        let mut a = self;\n        for i in 0..N {\n            result[i] = i;\n        }\n        for i in 1..N {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                    let old_j = result[j];\n                    result[j] = result[i];\n                    result[i] = old_j;\n                }\n            }\n        }\n        result\n    }\n\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\n// helper function used to look up the position of a value in an array of Field\n// Note that function returns 0 if the value is not found\nunconstrained fn find_index<N>(a: [u64; N], find: u64) -> u64 {\n    let mut result = 0;\n    for i in 0..a.len() {\n        if a[i] == find {\n            result = i;\n        }\n    }\n    result\n}\n","path":"std/array.nr"},"46":{"source":"use dep::std;\n\npub fn prefix_sha256_hash<N>(prefix_length: u8, input: [u8; N]) -> [u8; 32] {\n    let mut result = [0; 32];\n    assert([1, 2, 3, 114, 134, 243].any(|x| x == prefix_length), \"Length is not supported\");\n    if prefix_length == 1 {\n        result = std::hash::sha256(prefix(input, [0; 1]));\n    }\n    if prefix_length == 2 {\n        result = std::hash::sha256(prefix(input, [0; 2]));\n    }\n    if prefix_length == 3 {\n        result = std::hash::sha256(prefix(input, [0; 3]));\n    }\n    if prefix_length == 114 {\n        result = std::hash::sha256(prefix(input, [0; 114]));\n    }\n    if prefix_length == 134 {\n        result = std::hash::sha256(prefix(input, [0; 134]));\n    }\n    if prefix_length == 243 {\n        result = std::hash::sha256(prefix(input, [0; 243]));\n    }\n    result\n}\n\n\npub fn concatenate_arrays(a: [u8; 37], b: [u8; 32]) -> [u8; 69] {\n    let mut result = [0; 69];\n    for i in 0..37 {\n        result[i] = a[i];\n    }\n    for i in 0..32 {\n        result[i+37] = b[i];\n    }\n    result\n}\n\npub fn verify_identity(pub_key_x: [u8; 32], pub_key_y: [u8; 32], identity: str<40>) {\n    // Compute the publickey as concatenation of pub_key_x and pub_key_y\n    let mut pub_key = [0; 64];\n    for i in 0..32 {\n        pub_key[i] = pub_key_x[i];\n    }\n    for j in 0..32 {\n        pub_key[j+32] = pub_key_y[j];\n    }\n    // Compute the address as the hash of the publickey\n    let address: [u8; 32] = std::hash::sha256(pub_key);\n\n    // identity is the last 20bytes of the address.\n    // Assert that there is a match between identity provided and identity computed from pubkeys\n    for k in 0..20 {\n        assert(address[12 + k] == identity.from_hex_to_uint_slice(2*k, 2*k + 2) as u8);\n    }\n}\n\n\nfn prefix<N, M>(input: [u8; N], mut result: [u8; M]) -> [u8; M] {\n    for i in 0..M {\n        result[i] = input[i];\n    }\n    result\n}","path":"/home/maximilien/cairo-erc20-runner/noir-webauthn/src/utils.nr"},"47":{"source":"mod utils;\n\nuse dep::std;\nuse dep::std::println;\nuse crate::utils::{prefix_sha256_hash, concatenate_arrays, verify_identity};\n\nglobal CLIENT_DATA_JSON_LEN = 255;\n\nstruct ProgramOutputs {\n    authenticator_data: [u8; 37],\n    client_data_json_len: u8,\n    client_data_json: [u8; CLIENT_DATA_JSON_LEN],\n    signature: [u8; 64],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n}\n\n\nfn main(\n    version: pub u32,\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    identity_len: pub u8,\n    identity: pub str<40>,\n    tx_hash_len: pub u32,\n    tx_hash: pub [u8; 43],\n    program_outputs: pub ProgramOutputs\n) {\n    let client_data_json_hash = prefix_sha256_hash(program_outputs.client_data_json_len, program_outputs.client_data_json);\n    let concat = concatenate_arrays(program_outputs.authenticator_data, client_data_json_hash);\n    let hashed_data = std::hash::sha256(concat);\n\n    // Verifying pub_key matches the identity\n    verify_identity(program_outputs.pub_key_x, program_outputs.pub_key_y, identity);\n\n\n    // The txhash IS the challenge\n    for i in 0..(tx_hash.len()) {\n        assert(tx_hash[i] == program_outputs.client_data_json[36 + i]);\n    }\n\n    let valid_signature = std::ecdsa_secp256r1::verify_signature(program_outputs.pub_key_x, program_outputs.pub_key_y, program_outputs.signature, hashed_data);\n    \n    assert(valid_signature);\n    assert(tx_hash_len == 43);\n    assert(identity_len == 40);\n}\n\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_134() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,125,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // Padding with 121 zeros (134+121 = 255) \n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0\n    ];\n    let signature = [80,114,197,245,128,150,206,160,135,105,51,205,42,143,25,53,119,97,166,196,95,98,53,63,168,171,63,85,41,42,196,134,26,198,126,179,109,99,41,92,86,45,240,238,196,106,77,219,146,196,183,80,225,170,66,218,169,244,230,252,61,213,29,201];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [201,91,99,172,65,154,80,154,189,195,194,210,62,219,224,36,43,134,143,236,137,178,121,35,112,146,103,238,37,100,145,26];\n    let pub_key_y = [169,8,63,83,58,93,192,39,114,115,138,176,56,254,162,127,93,19,156,93,51,9,194,161,253,10,203,128,171,254,255,83];\n\n    let program_outputs = ProgramOutputs {\n            authenticator_data,\n            client_data_json_len: 134,\n            client_data_json,\n            signature,\n            pub_key_x,\n            pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 1;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 1;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 40;\n    let identity = \"c59b18d3bdaccb4d689048559a9bb6e8265293bf\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        program_outputs,\n    );\n}\n\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_243() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,44,34,111,116,104,101,114,95,107,101,121,115,95,99,97,110,95,98,101,95,97,100,100,101,100,95,104,101,114,101,34,58,34,100,111,32,110,111,116,32,99,111,109,112,97,114,101,32,99,108,105,101,110,116,68,97,116,97,74,83,79,78,32,97,103,97,105,110,115,116,32,97,32,116,101,109,112,108,97,116,101,46,32,83,101,101,32,104,116,116,112,115,58,47,47,103,111,111,46,103,108,47,121,97,98,80,101,120,34,125,\n        0,0,0,0,0,0,0,0,0,0,0,0 // Padding with 12 zeros (243+12 = 255) \n    ];\n    let signature = [35,9,110,138,212,71,172,124,13,7,194,158,153,63,87,67,67,25,22,122,101,253,159,175,106,50,52,157,164,70,148,46,126,152,146,190,137,37,199,95,249,115,198,94,237,198,18,23,200,185,52,157,189,205,144,63,212,29,177,20,24,255,160,127];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [15,206,241,12,21,160,54,11,79,72,44,109,43,45,101,54,210,243,13,236,51,33,47,66,187,38,60,249,64,70,37,252];\n    let pub_key_y = [43,221,114,86,240,184,224,51,237,41,173,85,147,130,225,150,159,150,44,23,57,92,82,37,27,40,69,123,252,224,3,197];\n    \n    let program_outputs = ProgramOutputs {\n        authenticator_data,\n        client_data_json_len: 243,\n        client_data_json,\n        signature,\n        pub_key_x,\n        pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 1;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 1;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 40;\n    let identity = \"3f368bf90c71946fc7b0cde9161ace42985d235f\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        program_outputs,\n    );\n}\n\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_243_bis() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,44,34,111,116,104,101,114,95,107,101,121,115,95,99,97,110,95,98,101,95,97,100,100,101,100,95,104,101,114,101,34,58,34,100,111,32,110,111,116,32,99,111,109,112,97,114,101,32,99,108,105,101,110,116,68,97,116,97,74,83,79,78,32,97,103,97,105,110,115,116,32,97,32,116,101,109,112,108,97,116,101,46,32,83,101,101,32,104,116,116,112,115,58,47,47,103,111,111,46,103,108,47,121,97,98,80,101,120,34,125,\n        0,0,0,0,0,0,0,0,0,0,0,0 // Padding with 12 zeros (243+12 = 255) \n    ];\n    let signature = [216,184,64,61,79,81,150,39,72,191,167,234,52,253,225,66,52,192,76,159,65,164,134,34,212,255,104,99,14,53,71,115,0,190,96,135,49,186,213,189,93,36,212,143,36,92,27,42,44,103,95,153,46,59,158,22,223,196,84,102,51,209,135,233];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [35,250,194,235,47,86,159,70,36,137,145,195,83,245,203,137,12,28,43,171,167,226,44,90,199,107,235,0,229,229,133,67];\n    let pub_key_y = [84,107,152,100,72,140,98,57,186,30,76,187,129,194,209,158,96,37,254,211,60,198,27,227,167,247,204,51,145,53,120,95];\n\n    let program_outputs = ProgramOutputs {\n        authenticator_data,\n        client_data_json_len: 243,\n        client_data_json,\n        signature,\n        pub_key_x,\n        pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 1;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 1;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 40;\n    let identity = \"ae0e5100ea7d28905ce690194c0717cd93756a20\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        program_outputs,\n    );\n}\n","path":"/home/maximilien/cairo-erc20-runner/noir-webauthn/src/main.nr"},"48":{"source":"use dep::std::println;\n\nglobal UPPERCASE_A_INDEX: u8 = 65;\nglobal UPPERCASE_Z_INDEX: u8 = 90;\nglobal LOWERCASE_A_INDEX: u8 = 97;\nglobal LOWERCASE_Z_INDEX: u8 = 122;\nglobal ZERO_INDEX: u8 = 48;\nglobal NINE_INDEX: u8 = 57;\nglobal ASCII_TABLE_START_INDEX: u8 = 0;\nglobal SORTED_ASCII_TABLE: [str<1>; 127] = [    \n    \"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\t\",\"\\n\",\"\\0\",\"\\0\",\"\\r\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\n    \" \",\"!\",\"\\\"\",\"#\",\"$\",\"%\",\"&\",\"'\",\"(\",\")\",\"*\",\"+\",\",\",\"-\",\".\",\"/\",\n    \"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\n    \":\",\";\",\"<\",\"=\",\">\",\"?\",\"@\",\n    \"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\",\n    \"[\",\"\\\\\",\"]\",\"^\",\"_\",\"`\",\n    \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\n    \"{\",\"|\",\"}\",\"~\"\n];\n\n// Functions \nfn code_at<N>(s: str<N>, index: u64) -> u8 {\n    assert(index < N);\n    s.as_bytes()[index]\n}\n\nfn char_at<N>(s: str<N>, index: u64) -> str<1> {\n    let byte = code_at(s, index);\n    let ascii_index = byte - ASCII_TABLE_START_INDEX;\n    SORTED_ASCII_TABLE[ascii_index]\n}\n\nfn index_of<N, M>(s: str<N>, substr: str<M>) -> i64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    for i in 0..N {\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            index = i as i64;\n            match_count += 1;\n        } else if (index != -1) & (i - index < M) {\n            if (str_bytes[i] != substr_bytes[i - index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    // If the match count is not equal to the length of the substring,\n    // then the substring is not in the string\n    // Can happen when looking at a substring that is at the end of the string\n    // but the match is only partial\n    if match_count != M {\n        index = -1;\n    }\n\n    index\n}\n\nfn last_index_of<N, M>(s: str<N>, substr: str<M>) -> i64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    let mut final_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    for i in 0..N {\n        if (match_count == M) {\n            final_index = temp_index;\n            temp_index = -1;\n            match_count = 0;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        final_index = temp_index;\n    }\n\n    final_index\n}\n\n// We use Field instead of integers for the Vector here as integers \n// don't seem to work well with Vectors at the moment\nfn indexes_of<N, M>(s: str<N>, substr: str<M>) -> Vec<Field> {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    let mut indexes: Vec<Field> = Vec::new();\n    for i in 0..N {\n        if (match_count == M) {\n            indexes.push(temp_index as Field);\n            temp_index = -1;\n            match_count = 0;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        indexes.push(temp_index as Field);\n    }\n\n    indexes\n}\n\nfn contains<N, M>(s: str<N>, substr: str<M>) -> bool {\n    index_of(s, substr) != -1\n}\n\nfn occurrences_of<N, M>(s: str<N>, substr: str<M>) -> u64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    let mut occurrences = 0;\n    for i in 0..N {\n        if (match_count == M) {\n            temp_index = -1;\n            match_count = 0;\n            occurrences += 1;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        occurrences += 1;\n    }\n\n    occurrences\n}\n\nfn digit_at<N>(s: str<N>, index: u64) -> u8 {\n    let byte = s.as_bytes()[index];\n    assert((byte >= ZERO_INDEX) & (byte <= NINE_INDEX), \"Character is not a digit\");\n    byte - ZERO_INDEX\n}\n\nfn hex_digit_at<N>(s: str<N>, index: u64) -> u8 {\n    let byte = s.as_bytes()[index];\n    if (byte >= ZERO_INDEX) & (byte <= NINE_INDEX) {\n        byte - ZERO_INDEX\n    } else if (byte >= UPPERCASE_A_INDEX) & (byte <= UPPERCASE_Z_INDEX) {\n        byte - UPPERCASE_A_INDEX + 10\n    } else if (byte >= LOWERCASE_A_INDEX) & (byte <= LOWERCASE_Z_INDEX) {\n        byte - LOWERCASE_A_INDEX + 10\n    } else {\n        assert(false, \"Character is not a hex digit\");\n        0\n    }\n}\n\nfn to_uint_slice<N>(s: str<N>, start: u64, end: u64) -> u64 {\n    let mut result = 0;\n    for i in start..end {\n        let digit = digit_at(s, i);\n        result = result * 10 + digit as u64;\n    }\n    result\n}\n\nfn to_uint<N>(s: str<N>) -> u64 {\n    to_uint_slice(s, 0, N)\n}\n\nfn to_int<N>(s: str<N>) -> i64 {\n    if char_at(s, 0) == \"-\" {\n        -1 * to_uint_slice(s, 1, N) as i64\n    } else {\n        to_uint_slice(s, 0, N) as i64\n    }\n}\n\nfn from_hex_to_uint_slice<N>(s: str<N>, start: u64, end: u64) -> u64 {\n    let mut result = 0;\n    for i in start..end {\n        let digit = hex_digit_at(s, i);\n        result = result * 16 + digit as u64;\n    }\n    result\n}\n\nfn from_hex_to_uint<N>(s: str<N>, with_prefix: bool) -> u64 {\n    if with_prefix {\n        from_hex_to_uint_slice(s, 2, N)\n    } else {\n        from_hex_to_uint_slice(s, 0, N)\n    }\n}\n\nfn to_array_of_chars<N>(s: str<N>) -> [str<1>; N] {\n    let mut result: [str<1>; N] = [\" \"; N];\n    for i in 0..N {\n        result[i] = char_at(s, i);\n    }\n    result\n}\n\n// Struct\n\nstruct String<N> {\n    value: str<N>,\n    len: u64,\n}\n\n// Implementation over String struct\n\nimpl<N> String<N> {\n    fn new(value: str<N>) -> Self {\n        Self { value, len: N }\n    }\n\n    fn code_at(self: Self, index: u64) -> u8 {\n        code_at(self.value, index)\n    }\n\n    fn char_at(self: Self, index: u64) -> str<1> {\n        char_at(self.value, index)\n    }\n\n    fn index_of<M>(self: Self, substr: str<M>) -> i64 {\n        index_of(self.value, substr)\n    }\n\n    fn last_index_of<M>(self: Self, substr: str<M>) -> i64 {\n        last_index_of(self.value, substr)\n    }\n\n    fn indexes_of<M>(self: Self, substr: str<M>) -> Vec<Field> {\n        indexes_of(self.value, substr)\n    }\n\n    fn contains<M>(self: Self, substr: str<M>) -> bool {\n        contains(self.value, substr)\n    }\n\n    fn occurrences_of<M>(self: Self, substr: str<M>) -> u64 {\n        occurrences_of(self.value, substr)\n    }\n\n    fn digit_at(self: Self, index: u64) -> u8 {\n        digit_at(self.value, index)\n    }\n\n    fn hex_digit_at(self: Self, index: u64) -> u8 {\n        hex_digit_at(self.value, index)\n    }\n\n    fn to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        to_uint_slice(self.value, start, end)\n    }\n\n    fn to_uint(self: Self) -> u64 {\n        to_uint_slice(self.value, 0, self.len)\n    }\n\n    fn to_int(self: Self) -> i64 {\n        to_int(self.value)\n    }\n\n    fn from_hex_to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        from_hex_to_uint_slice(self.value, start, end)\n    }\n\n    fn from_hex_to_uint(self: Self, with_prefix: bool) -> u64 {\n        from_hex_to_uint(self.value, with_prefix)\n    }\n\n    fn to_array_of_chars(self: Self) -> [str<1>; N] {\n        to_array_of_chars(self.value)\n    }\n}\n\n// Trait\ntrait StringTrait {\n    fn code_at(self, index: u64) -> u8;\n    fn char_at(self, index: u64) -> str<1>;\n    fn index_of<M>(self, substr: str<M>) -> i64;\n    fn last_index_of<M>(self, c: str<M>) -> i64;\n    fn indexes_of<M>(self, c: str<M>) -> Vec<Field>;\n    fn contains<M>(self, substr: str<M>) -> bool;\n    fn occurrences_of<M>(self, c: str<M>) -> u64;\n    fn digit_at(self, index: u64) -> u8;\n    fn hex_digit_at(self, index: u64) -> u8;\n    fn to_uint_slice(self, start: u64, end: u64) -> u64;\n    fn to_uint(self) -> u64;\n    fn to_int(self) -> i64;\n    fn from_hex_to_uint_slice(self, start: u64, end: u64) -> u64;\n    fn from_hex_to_uint(self, with_prefix: bool) -> u64;\n}\n\n// Implementation for str type\nimpl<N> StringTrait for str<N> {\n    fn code_at(self: Self, index: u64) -> u8 {\n        code_at(self, index)\n    }\n\n    fn char_at(self: Self, index: u64) -> str<1> {\n        char_at(self, index)\n    }\n\n    fn index_of<M>(self: Self, substr: str<M>) -> i64 {\n        index_of(self, substr)\n    }\n\n    fn last_index_of<M>(self: Self, substr: str<M>) -> i64 {\n        last_index_of(self, substr)\n    }\n\n    fn indexes_of<M>(self: Self, substr: str<M>) -> Vec<Field> {\n        indexes_of(self, substr)\n    }\n\n    fn contains<M>(self: Self, substr: str<M>) -> bool {\n        contains(self, substr)\n    }\n\n    fn occurrences_of<M>(self: Self, substr: str<M>) -> u64 {\n        occurrences_of(self, substr)\n    }\n\n    fn digit_at(self: Self, index: u64) -> u8 {\n        digit_at(self, index)\n    }\n\n    fn hex_digit_at(self: Self, index: u64) -> u8 {\n        hex_digit_at(self, index)\n    }\n\n    fn to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        to_uint_slice(self, start, end)\n    }\n\n    fn to_uint(self: Self) -> u64 {\n        to_uint_slice(self, 0, N)\n    }\n\n    fn to_int(self: Self) -> i64 {\n        to_int(self)\n    }\n\n    fn from_hex_to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        from_hex_to_uint_slice(self, start, end)\n    }\n\n    fn from_hex_to_uint(self: Self, with_prefix: bool) -> u64 {\n        from_hex_to_uint(self, with_prefix)\n    }\n}\n\n// Tests for String struct\n#[test]\nfn test_init() {\n    let s = String::new(\"hello\");\n    assert(s.len == 5);\n    assert(s.value == \"hello\");\n}\n\n#[test]\nfn test_char_at() {\n    let s = String::new(\"hello\");\n    assert(s.char_at(0) == \"h\");\n    assert(s.char_at(1) == \"e\");\n    assert(s.char_at(2) == \"l\");\n    assert(s.char_at(3) == \"l\");\n    assert(s.char_at(4) == \"o\");\n}\n\n#[test]\nfn test_code_at() {\n    let s = String::new(\"hello\");\n    assert(s.code_at(0) == 104);\n    assert(s.code_at(1) == 101);\n    assert(s.code_at(2) == 108);\n    assert(s.code_at(3) == 108);\n    assert(s.code_at(4) == 111);\n}\n\n#[test]\nfn test_index_of() {\n    let s = String::new(\"hello\");\n    // Characters\n    assert(s.index_of(\"h\") == 0);\n    assert(s.index_of(\"e\") == 1);\n    assert(s.index_of(\"l\") == 2);\n    assert(s.index_of(\"o\") == 4);\n    assert(s.index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.index_of(\"he\") == 0);\n    assert(s.index_of(\"el\") == 1);\n    assert(s.index_of(\"ll\") == 2);\n    assert(s.index_of(\"lo\") == 3);\n    assert(s.index_of(\"hello\") == 0);\n    assert(s.index_of(\"ow\") == -1);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.index_of(\"some\") == 0);\n    assert(sentence.index_of(\"sentence\") == 5);\n    assert(sentence.index_of(\"with\") == 14);\n    assert(sentence.index_of(\"repetition\") == 24);\n    assert(sentence.index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.index_of(\"ti\") == 28);\n}\n\n#[test]\nfn test_last_index_of() {\n    let s = String::new(\"hello\");\n    assert(s.last_index_of(\"h\") == 0);\n    assert(s.last_index_of(\"e\") == 1);\n    assert(s.last_index_of(\"l\") == 3);\n    assert(s.last_index_of(\"o\") == 4);\n    assert(s.last_index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.last_index_of(\"he\") == 0);\n    assert(s.last_index_of(\"el\") == 1);\n    assert(s.last_index_of(\"ll\") == 2);\n    assert(s.last_index_of(\"lo\") == 3);\n    assert(s.last_index_of(\"hello\") == 0);\n    assert(s.last_index_of(\"ow\") == -1);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.last_index_of(\"some\") == 19);\n    assert(sentence.last_index_of(\"sentence\") == 5);\n    assert(sentence.last_index_of(\"with\") == 14);\n    assert(sentence.last_index_of(\"repetition\") == 24);\n    assert(sentence.last_index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.last_index_of(\"ti\") == 30);\n}\n\n#[test]\nfn test_indexes_of() {\n    let s = String::new(\"hello\");\n    assert(s.indexes_of(\"h\").get(0) == 0);\n    assert(s.indexes_of(\"e\").get(0) == 1);\n    assert(s.indexes_of(\"l\").get(0) == 2);\n    assert(s.indexes_of(\"l\").get(1) == 3);\n    assert(s.indexes_of(\"o\").get(0) == 4);\n    assert(s.indexes_of(\"a\").len() == 0);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.indexes_of(\"some\").get(0) == 0);\n    assert(sentence.indexes_of(\"some\").get(1) == 19);\n    assert(sentence.indexes_of(\"sentence\").get(0) == 5);\n    assert(sentence.indexes_of(\"with\").get(0) == 14);\n    assert(sentence.indexes_of(\"repetition\").get(0) == 24);\n    assert(sentence.indexes_of(\"some sentence with some repetition\").get(0) == 0);\n    assert(sentence.indexes_of(\"ti\").get(0) == 28);\n    assert(sentence.indexes_of(\"ti\").get(1) == 30);\n    assert(sentence.indexes_of(\"a\").len() == 0);\n}\n\n#[test]\nfn test_contains() {\n    let s = String::new(\"hello\");\n    assert(s.contains(\"h\"));\n    assert(s.contains(\"e\"));\n    assert(s.contains(\"l\"));\n    assert(s.contains(\"o\"));\n    assert(!s.contains(\"a\"));\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.contains(\"some\"));\n    assert(sentence.contains(\"sentence\"));\n    assert(sentence.contains(\"with\"));\n    assert(sentence.contains(\"repetition\"));\n    assert(sentence.contains(\"ti\"));\n    assert(!sentence.contains(\"hello\"));\n    assert(!sentence.contains(\"a\"));\n}\n\n#[test]\nfn test_occurrences_of() {\n    let s = String::new(\"hello\");\n    assert(s.occurrences_of(\"h\") == 1);\n    assert(s.occurrences_of(\"e\") == 1);\n    assert(s.occurrences_of(\"l\") == 2);\n    assert(s.occurrences_of(\"o\") == 1);\n    assert(s.occurrences_of(\"a\") == 0);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.occurrences_of(\"some\") == 2);\n    assert(sentence.occurrences_of(\"sentence\") == 1);\n    assert(sentence.occurrences_of(\"with\") == 1);\n    assert(sentence.occurrences_of(\"repetition\") == 1);\n    assert(sentence.occurrences_of(\"ti\") == 2);\n    assert(sentence.occurrences_of(\"hello\") == 0);\n    assert(sentence.occurrences_of(\"a\") == 0);\n}\n\n#[test]\nfn test_digit_at() {\n    let s = String::new(\"20231219\");\n    assert(s.digit_at(0) == 2);\n    assert(s.digit_at(1) == 0);\n    assert(s.digit_at(2) == 2);\n    assert(s.digit_at(3) == 3);\n    assert(s.digit_at(4) == 1);\n    assert(s.digit_at(5) == 2);\n    assert(s.digit_at(6) == 1);\n    assert(s.digit_at(7) == 9);\n}\n\n#[test]\nfn test_hex_digit_at() {\n    let s = String::new(\"0x1324ABCDEF\");\n    assert(s.hex_digit_at(2) == 1);\n    assert(s.hex_digit_at(3) == 3);\n    assert(s.hex_digit_at(4) == 2);\n    assert(s.hex_digit_at(5) == 4);\n    assert(s.hex_digit_at(6) == 10);\n    assert(s.hex_digit_at(7) == 11);\n    assert(s.hex_digit_at(8) == 12);\n    assert(s.hex_digit_at(9) == 13);\n    assert(s.hex_digit_at(10) == 14);\n    assert(s.hex_digit_at(11) == 15);\n}\n\n#[test]\nfn test_to_uint() {\n    let s = String::new(\"20231219\");\n    assert(s.to_uint() == 20231219);\n}\n\n#[test]\nfn test_to_int() {\n    let s = String::new(\"-25\");\n    assert(s.to_int() == -25);\n\n    let s = String::new(\"25\");\n    assert(s.to_int() == 25);\n}\n\n#[test]\nfn test_to_uint_slice() {\n    let s = String::new(\"2023/12/19\");\n    assert(s.to_uint_slice(0, 4) == 2023);\n    assert(s.to_uint_slice(5, 7) == 12);\n    assert(s.to_uint_slice(8, 10) == 19);\n}\n\n#[test]\nfn test_from_hex_to_uint_slice() {\n    let s = String::new(\"0x1324ABCDEF\");\n    assert(s.from_hex_to_uint_slice(2, 6) == 0x1324);\n    assert(s.from_hex_to_uint_slice(6, 9) == 0xABC);\n    assert(s.from_hex_to_uint_slice(9, 12) == 0xDEF);\n}\n\n#[test]\nfn test_from_hex_to_uint() {\n    let uppercase_hex = String::new(\"0x1324ABCDEF\");\n    assert(uppercase_hex.from_hex_to_uint(true) == 0x1324ABCDEF);\n\n    let lowercase_hex = String::new(\"0x1234abcdef\");\n    assert(lowercase_hex.from_hex_to_uint(true) == 0x1234ABCDEF);\n\n    let hex_without_prefix = String::new(\"1234abcdef\");\n    assert(hex_without_prefix.from_hex_to_uint(false) == 0x1234ABCDEF);\n\n    let hex_with_leading_zeros = String::new(\"0x000001\");\n    assert(hex_with_leading_zeros.from_hex_to_uint(true) == 1);\n}\n\n#[test]\nfn test_to_array_of_chars() {\n    let s = String::new(\"hello\");\n    let arr = s.to_array_of_chars();\n    assert(arr[0] == \"h\");\n    assert(arr[1] == \"e\");\n    assert(arr[2] == \"l\");\n    assert(arr[3] == \"l\");\n    assert(arr[4] == \"o\");\n}\n\n// Tests for String trait\n#[test]\nfn test_trait_char_at() {\n    let s = \"hello\";\n    assert(s.char_at(0) == \"h\");\n    assert(s.char_at(1) == \"e\");\n    assert(s.char_at(2) == \"l\");\n    assert(s.char_at(3) == \"l\");\n    assert(s.char_at(4) == \"o\");\n}\n\n#[test]\nfn test_trait_code_at() {\n    let s = \"hello\";\n    assert(s.code_at(0) == 104);\n    assert(s.code_at(1) == 101);\n    assert(s.code_at(2) == 108);\n    assert(s.code_at(3) == 108);\n    assert(s.code_at(4) == 111);\n}\n\n#[test]\nfn test_trait_index_of() {\n    let s = \"hello\";\n    // Characters\n    assert(s.index_of(\"h\") == 0);\n    assert(s.index_of(\"e\") == 1);\n    assert(s.index_of(\"l\") == 2);\n    assert(s.index_of(\"o\") == 4);\n    assert(s.index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.index_of(\"he\") == 0);\n    assert(s.index_of(\"el\") == 1);\n    assert(s.index_of(\"ll\") == 2);\n    assert(s.index_of(\"lo\") == 3);\n    assert(s.index_of(\"hello\") == 0);\n    assert(s.index_of(\"ow\") == -1);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.index_of(\"some\") == 0);\n    assert(sentence.index_of(\"sentence\") == 5);\n    assert(sentence.index_of(\"with\") == 14);\n    assert(sentence.index_of(\"repetition\") == 24);\n    assert(sentence.index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.index_of(\"ti\") == 28);\n}\n\n#[test]\nfn test_trait_last_index_of() {\n    let s = \"hello\";\n    // Characters\n    assert(s.last_index_of(\"h\") == 0);\n    assert(s.last_index_of(\"e\") == 1);\n    assert(s.last_index_of(\"l\") == 3);\n    assert(s.last_index_of(\"o\") == 4);\n    assert(s.last_index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.last_index_of(\"he\") == 0);\n    assert(s.last_index_of(\"el\") == 1);\n    assert(s.last_index_of(\"ll\") == 2);\n    assert(s.last_index_of(\"lo\") == 3);\n    assert(s.last_index_of(\"hello\") == 0);\n    assert(s.last_index_of(\"ow\") == -1);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.last_index_of(\"some\") == 19);\n    assert(sentence.last_index_of(\"sentence\") == 5);\n    assert(sentence.last_index_of(\"with\") == 14);\n    assert(sentence.last_index_of(\"repetition\") == 24);\n    assert(sentence.last_index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.last_index_of(\"ti\") == 30);\n}\n\n#[test]\nfn test_trait_indexes_of() {\n    let s = \"hello\";\n    assert(s.indexes_of(\"h\").get(0) == 0);\n    assert(s.indexes_of(\"e\").get(0) == 1);\n    assert(s.indexes_of(\"l\").get(0) == 2);\n    assert(s.indexes_of(\"l\").get(1) == 3);\n    assert(s.indexes_of(\"o\").get(0) == 4);\n    assert(s.indexes_of(\"a\").len() == 0);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.indexes_of(\"some\").get(0) == 0);\n    assert(sentence.indexes_of(\"some\").get(1) == 19);\n    assert(sentence.indexes_of(\"sentence\").get(0) == 5);\n    assert(sentence.indexes_of(\"with\").get(0) == 14);\n    assert(sentence.indexes_of(\"repetition\").get(0) == 24);\n    assert(sentence.indexes_of(\"some sentence with some repetition\").get(0) == 0);\n    assert(sentence.indexes_of(\"ti\").get(0) == 28);\n    assert(sentence.indexes_of(\"ti\").get(1) == 30);\n    assert(sentence.indexes_of(\"a\").len() == 0);\n}\n\n#[test]\nfn test_trait_contains() {\n    let s = \"hello\";\n    assert(s.contains(\"h\"));\n    assert(s.contains(\"e\"));\n    assert(s.contains(\"l\"));\n    assert(s.contains(\"o\"));\n    assert(!s.contains(\"a\"));\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.contains(\"some\"));\n    assert(sentence.contains(\"sentence\"));\n    assert(sentence.contains(\"with\"));\n    assert(sentence.contains(\"repetition\"));\n    assert(sentence.contains(\"ti\"));\n    assert(!sentence.contains(\"hello\"));\n    assert(!sentence.contains(\"a\"));\n}\n\n#[test]\nfn test_trait_occurrences_of() {\n    let s = \"hello\";\n    assert(s.occurrences_of(\"h\") == 1);\n    assert(s.occurrences_of(\"e\") == 1);\n    assert(s.occurrences_of(\"l\") == 2);\n    assert(s.occurrences_of(\"o\") == 1);\n    assert(s.occurrences_of(\"a\") == 0);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.occurrences_of(\"some\") == 2);\n    assert(sentence.occurrences_of(\"sentence\") == 1);\n    assert(sentence.occurrences_of(\"with\") == 1);\n    assert(sentence.occurrences_of(\"repetition\") == 1);\n    assert(sentence.occurrences_of(\"ti\") == 2);\n    assert(sentence.occurrences_of(\"hello\") == 0);\n    assert(sentence.occurrences_of(\"a\") == 0);\n}\n\n#[test]\nfn test_trait_digit_at() {\n    let s = \"20231219\";\n    assert(s.digit_at(0) == 2);\n    assert(s.digit_at(1) == 0);\n    assert(s.digit_at(2) == 2);\n    assert(s.digit_at(3) == 3);\n    assert(s.digit_at(4) == 1);\n    assert(s.digit_at(5) == 2);\n    assert(s.digit_at(6) == 1);\n    assert(s.digit_at(7) == 9);\n}\n\n#[test]\nfn test_trait_hex_digit_at() {\n    let s = \"0x1324ABCDEF\";\n    assert(s.hex_digit_at(2) == 1);\n    assert(s.hex_digit_at(3) == 3);\n    assert(s.hex_digit_at(4) == 2);\n    assert(s.hex_digit_at(5) == 4);\n    assert(s.hex_digit_at(6) == 10);\n    assert(s.hex_digit_at(7) == 11);\n    assert(s.hex_digit_at(8) == 12);\n    assert(s.hex_digit_at(9) == 13);\n    assert(s.hex_digit_at(10) == 14);\n    assert(s.hex_digit_at(11) == 15);\n}\n\n#[test]\nfn test_trait_to_uint() {\n    let s = \"20231219\";\n    assert(s.to_uint() == 20231219);\n}\n\n#[test]\nfn test_trait_to_int() {\n    let s = \"-25\";\n    assert(s.to_int() == -25);\n\n    let s = \"25\";\n    assert(s.to_int() == 25);\n}\n\n#[test]\nfn test_trait_to_uint_slice() {\n    let s = \"2023/12/19\";\n    assert(s.to_uint_slice(0, 4) == 2023);\n    assert(s.to_uint_slice(5, 7) == 12);\n    assert(s.to_uint_slice(8, 10) == 19);\n}\n\n#[test]\nfn test_trait_from_hex_to_uint_slice() {\n    let s = \"0x1324ABCDEF\";\n    assert(s.from_hex_to_uint_slice(2, 6) == 0x1324);\n    assert(s.from_hex_to_uint_slice(6, 9) == 0xABC);\n    assert(s.from_hex_to_uint_slice(9, 12) == 0xDEF);\n}\n\n#[test]\nfn test_trait_from_hex_to_uint() {\n    let uppercase_hex = \"0x1324ABCDEF\";\n    assert(uppercase_hex.from_hex_to_uint(true) == 0x1324ABCDEF);\n\n    let lowercase_hex = \"0x1234abcdef\";\n    assert(lowercase_hex.from_hex_to_uint(true) == 0x1234ABCDEF);\n\n    let hex_without_prefix = \"1234abcdef\";\n    assert(hex_without_prefix.from_hex_to_uint(false) == 0x1234ABCDEF);\n\n    let hex_with_leading_zeros = \"0x000001\";\n    assert(hex_with_leading_zeros.from_hex_to_uint(true) == 1);\n}\n","path":"/home/maximilien/nargo/github.com/madztheo/noir-string-utils.gitmain/src/lib.nr"}},"names":["main"]}
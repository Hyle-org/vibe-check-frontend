{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":15992366327228886641,"abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":56},"visibility":"public"},{"name":"tx_hash_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"tx_hash","type":{"kind":"array","length":43,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"program_outputs","type":{"kind":"struct","path":"ProgramOutputs","fields":[{"name":"authenticator_data","type":{"kind":"array","length":37,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"client_data_json_len","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"client_data_json","type":{"kind":"array","length":255,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"public"}],"param_witnesses":{"identity":[{"start":12,"end":68}],"identity_len":[{"start":11,"end":12}],"initial_state":[{"start":2,"end":6}],"initial_state_len":[{"start":1,"end":2}],"next_state":[{"start":7,"end":11}],"next_state_len":[{"start":6,"end":7}],"program_outputs":[{"start":112,"end":533}],"tx_hash":[{"start":69,"end":112}],"tx_hash_len":[{"start":68,"end":69}],"version":[{"start":0,"end":1}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"1":{"source":"use crate::cmp::Ord;\n\n// TODO: Once we fully move to the new SSA pass this module can be removed and replaced\n// by the methods in the `slice` module\nimpl<T, N> [T; N] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u64 {}\n\n    pub fn sort(self) -> Self where T: Ord {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        let sorted_index = self.get_sorting_index(ordering);\n        let mut result = self;\n        // Ensure the indexes are correct\n        for i in 0..N {\n            let pos = find_index(sorted_index, i);\n            assert(sorted_index[pos] == i);\n        }\n        // Sort the array using the indexes\n        for i in 0..N {\n            result[i] = self[sorted_index[i]];\n        }\n        // Ensure the array is sorted\n        for i in 0..N - 1 {\n            assert(ordering(result[i], result[i + 1]));\n        }\n\n        result\n    }\n\n    /// Returns the index of the elements in the array that would sort it, using the provided custom sorting function.\n    unconstrained fn get_sorting_index<Env>(self, ordering: fn[Env](T, T) -> bool) -> [u64; N] {\n        let mut result = [0; N];\n        let mut a = self;\n        for i in 0..N {\n            result[i] = i;\n        }\n        for i in 1..N {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                    let old_j = result[j];\n                    result[j] = result[i];\n                    result[i] = old_j;\n                }\n            }\n        }\n        result\n    }\n\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\n// helper function used to look up the position of a value in an array of Field\n// Note that function returns 0 if the value is not found\nunconstrained fn find_index<N>(a: [u64; N], find: u64) -> u64 {\n    let mut result = 0;\n    for i in 0..a.len() {\n        if a[i] == find {\n            result = i;\n        }\n    }\n    result\n}\n","path":"std/array.nr"},"46":{"source":"use dep::std;\n\npub fn prefix_sha256_hash<N>(prefix_length: u8, input: [u8; N]) -> [u8; 32] {\n    let mut result = [0; 32];\n    assert([1, 2, 3, 114, 134, 243].any(|x| x == prefix_length), \"Length is not supported\");\n    if prefix_length == 1 {\n        result = std::hash::sha256(prefix(input, [0; 1]));\n    }\n    if prefix_length == 2 {\n        result = std::hash::sha256(prefix(input, [0; 2]));\n    }\n    if prefix_length == 3 {\n        result = std::hash::sha256(prefix(input, [0; 3]));\n    }\n    if prefix_length == 114 {\n        result = std::hash::sha256(prefix(input, [0; 114]));\n    }\n    if prefix_length == 134 {\n        result = std::hash::sha256(prefix(input, [0; 134]));\n    }\n    if prefix_length == 243 {\n        result = std::hash::sha256(prefix(input, [0; 243]));\n    }\n    result\n}\n\n\npub fn concatenate_arrays(a: [u8; 37], b: [u8; 32]) -> [u8; 69] {\n    let mut result = [0; 69];\n    for i in 0..37 {\n        result[i] = a[i];\n    }\n    for i in 0..32 {\n        result[i+37] = b[i];\n    }\n    result\n}\n\npub fn check_pubkey_matches_identity(pub_key_x: [u8; 32], pub_key_y: [u8; 32], identity: str<56>) {\n    // Compute the publickey as concatenation of pub_key_x and pub_key_y\n    let mut pub_key = [0; 64];\n    for i in 0..32 {\n        pub_key[i] = pub_key_x[i];\n    }\n    for j in 0..32 {\n        pub_key[j+32] = pub_key_y[j];\n    }\n    // Compute the address as the hash of the publickey\n    let address: [u8; 32] = std::hash::sha256(pub_key);\n\n    // identity is the last 20bytes of the address.\n    // Assert that there is a match between identity provided and identity computed from pubkeys\n    for k in 0..20 {\n        assert(address[12 + k] == identity.from_hex_to_uint_slice(2*k, 2*k + 2) as u8);\n    }\n}\n\n\nfn prefix<N, M>(input: [u8; N], mut result: [u8; M]) -> [u8; M] {\n    for i in 0..M {\n        result[i] = input[i];\n    }\n    result\n}","path":"/home/maximilien/cairo-erc20-runner/noir-webauthn/src/utils.nr"},"47":{"source":"mod utils;\n\nuse dep::std;\nuse dep::std::println;\nuse crate::utils::{prefix_sha256_hash, concatenate_arrays, check_pubkey_matches_identity};\n\nglobal CLIENT_DATA_JSON_LEN = 255;\n\nstruct ProgramOutputs {\n    authenticator_data: [u8; 37],\n    client_data_json_len: u8,\n    client_data_json: [u8; CLIENT_DATA_JSON_LEN],\n    signature: [u8; 64],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n}\n\n\nfn main(\n    version: pub u32,\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    identity_len: pub u8,\n    identity: pub str<56>,\n    tx_hash_len: pub u32,\n    tx_hash: pub [u8; 43],\n    program_outputs: pub ProgramOutputs\n) {\n    let client_data_json_hash = prefix_sha256_hash(program_outputs.client_data_json_len, program_outputs.client_data_json);\n    let concat = concatenate_arrays(program_outputs.authenticator_data, client_data_json_hash);\n    let hashed_data = std::hash::sha256(concat);\n\n    // Verifying pub_key matches the identity\n    check_pubkey_matches_identity(program_outputs.pub_key_x, program_outputs.pub_key_y, identity);\n\n\n    // The txhash IS the challenge\n    for i in 0..(tx_hash.len()) {\n        assert(tx_hash[i] == program_outputs.client_data_json[36 + i]);\n    }\n\n    let valid_signature = std::ecdsa_secp256r1::verify_signature(program_outputs.pub_key_x, program_outputs.pub_key_y, program_outputs.signature, hashed_data);\n    \n    assert(valid_signature);\n    assert(tx_hash_len == 43);\n    assert(identity_len == 56);\n}\n\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_134() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,125,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // Padding with 121 zeros (134+121 = 255) \n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0\n    ];\n    let signature = [80,114,197,245,128,150,206,160,135,105,51,205,42,143,25,53,119,97,166,196,95,98,53,63,168,171,63,85,41,42,196,134,26,198,126,179,109,99,41,92,86,45,240,238,196,106,77,219,146,196,183,80,225,170,66,218,169,244,230,252,61,213,29,201];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [201,91,99,172,65,154,80,154,189,195,194,210,62,219,224,36,43,134,143,236,137,178,121,35,112,146,103,238,37,100,145,26];\n    let pub_key_y = [169,8,63,83,58,93,192,39,114,115,138,176,56,254,162,127,93,19,156,93,51,9,194,161,253,10,203,128,171,254,255,83];\n\n    let program_outputs = ProgramOutputs {\n            authenticator_data,\n            client_data_json_len: 134,\n            client_data_json,\n            signature,\n            pub_key_x,\n            pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 1;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 1;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 56;\n    let identity = \"c59b18d3bdaccb4d689048559a9bb6e8265293bf.ecdsa_secp256r1\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        program_outputs,\n    );\n}\n\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_243() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,44,34,111,116,104,101,114,95,107,101,121,115,95,99,97,110,95,98,101,95,97,100,100,101,100,95,104,101,114,101,34,58,34,100,111,32,110,111,116,32,99,111,109,112,97,114,101,32,99,108,105,101,110,116,68,97,116,97,74,83,79,78,32,97,103,97,105,110,115,116,32,97,32,116,101,109,112,108,97,116,101,46,32,83,101,101,32,104,116,116,112,115,58,47,47,103,111,111,46,103,108,47,121,97,98,80,101,120,34,125,\n        0,0,0,0,0,0,0,0,0,0,0,0 // Padding with 12 zeros (243+12 = 255) \n    ];\n    let signature = [35,9,110,138,212,71,172,124,13,7,194,158,153,63,87,67,67,25,22,122,101,253,159,175,106,50,52,157,164,70,148,46,126,152,146,190,137,37,199,95,249,115,198,94,237,198,18,23,200,185,52,157,189,205,144,63,212,29,177,20,24,255,160,127];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [15,206,241,12,21,160,54,11,79,72,44,109,43,45,101,54,210,243,13,236,51,33,47,66,187,38,60,249,64,70,37,252];\n    let pub_key_y = [43,221,114,86,240,184,224,51,237,41,173,85,147,130,225,150,159,150,44,23,57,92,82,37,27,40,69,123,252,224,3,197];\n    \n    let program_outputs = ProgramOutputs {\n        authenticator_data,\n        client_data_json_len: 243,\n        client_data_json,\n        signature,\n        pub_key_x,\n        pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 1;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 1;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 56;\n    let identity = \"3f368bf90c71946fc7b0cde9161ace42985d235f.ecdsa_secp256r1\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        program_outputs,\n    );\n}\n\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_243_bis() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,44,34,111,116,104,101,114,95,107,101,121,115,95,99,97,110,95,98,101,95,97,100,100,101,100,95,104,101,114,101,34,58,34,100,111,32,110,111,116,32,99,111,109,112,97,114,101,32,99,108,105,101,110,116,68,97,116,97,74,83,79,78,32,97,103,97,105,110,115,116,32,97,32,116,101,109,112,108,97,116,101,46,32,83,101,101,32,104,116,116,112,115,58,47,47,103,111,111,46,103,108,47,121,97,98,80,101,120,34,125,\n        0,0,0,0,0,0,0,0,0,0,0,0 // Padding with 12 zeros (243+12 = 255) \n    ];\n    let signature = [216,184,64,61,79,81,150,39,72,191,167,234,52,253,225,66,52,192,76,159,65,164,134,34,212,255,104,99,14,53,71,115,0,190,96,135,49,186,213,189,93,36,212,143,36,92,27,42,44,103,95,153,46,59,158,22,223,196,84,102,51,209,135,233];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [35,250,194,235,47,86,159,70,36,137,145,195,83,245,203,137,12,28,43,171,167,226,44,90,199,107,235,0,229,229,133,67];\n    let pub_key_y = [84,107,152,100,72,140,98,57,186,30,76,187,129,194,209,158,96,37,254,211,60,198,27,227,167,247,204,51,145,53,120,95];\n\n    let program_outputs = ProgramOutputs {\n        authenticator_data,\n        client_data_json_len: 243,\n        client_data_json,\n        signature,\n        pub_key_x,\n        pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 1;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 1;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 56;\n    let identity = \"ae0e5100ea7d28905ce690194c0717cd93756a20.ecdsa_secp256r1\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        program_outputs,\n    );\n}\n","path":"/home/maximilien/cairo-erc20-runner/noir-webauthn/src/main.nr"},"48":{"source":"use dep::std::println;\n\nglobal UPPERCASE_A_INDEX: u8 = 65;\nglobal UPPERCASE_Z_INDEX: u8 = 90;\nglobal LOWERCASE_A_INDEX: u8 = 97;\nglobal LOWERCASE_Z_INDEX: u8 = 122;\nglobal ZERO_INDEX: u8 = 48;\nglobal NINE_INDEX: u8 = 57;\nglobal ASCII_TABLE_START_INDEX: u8 = 0;\nglobal SORTED_ASCII_TABLE: [str<1>; 127] = [    \n    \"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\t\",\"\\n\",\"\\0\",\"\\0\",\"\\r\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\n    \" \",\"!\",\"\\\"\",\"#\",\"$\",\"%\",\"&\",\"'\",\"(\",\")\",\"*\",\"+\",\",\",\"-\",\".\",\"/\",\n    \"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\n    \":\",\";\",\"<\",\"=\",\">\",\"?\",\"@\",\n    \"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\",\n    \"[\",\"\\\\\",\"]\",\"^\",\"_\",\"`\",\n    \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\n    \"{\",\"|\",\"}\",\"~\"\n];\n\n// Functions \nfn code_at<N>(s: str<N>, index: u64) -> u8 {\n    assert(index < N);\n    s.as_bytes()[index]\n}\n\nfn char_at<N>(s: str<N>, index: u64) -> str<1> {\n    let byte = code_at(s, index);\n    let ascii_index = byte - ASCII_TABLE_START_INDEX;\n    SORTED_ASCII_TABLE[ascii_index]\n}\n\nfn index_of<N, M>(s: str<N>, substr: str<M>) -> i64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    for i in 0..N {\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            index = i as i64;\n            match_count += 1;\n        } else if (index != -1) & (i - index < M) {\n            if (str_bytes[i] != substr_bytes[i - index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    // If the match count is not equal to the length of the substring,\n    // then the substring is not in the string\n    // Can happen when looking at a substring that is at the end of the string\n    // but the match is only partial\n    if match_count != M {\n        index = -1;\n    }\n\n    index\n}\n\nfn last_index_of<N, M>(s: str<N>, substr: str<M>) -> i64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    let mut final_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    for i in 0..N {\n        if (match_count == M) {\n            final_index = temp_index;\n            temp_index = -1;\n            match_count = 0;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        final_index = temp_index;\n    }\n\n    final_index\n}\n\n// We use Field instead of integers for the Vector here as integers \n// don't seem to work well with Vectors at the moment\nfn indexes_of<N, M>(s: str<N>, substr: str<M>) -> Vec<Field> {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    let mut indexes: Vec<Field> = Vec::new();\n    for i in 0..N {\n        if (match_count == M) {\n            indexes.push(temp_index as Field);\n            temp_index = -1;\n            match_count = 0;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        indexes.push(temp_index as Field);\n    }\n\n    indexes\n}\n\nfn contains<N, M>(s: str<N>, substr: str<M>) -> bool {\n    index_of(s, substr) != -1\n}\n\nfn occurrences_of<N, M>(s: str<N>, substr: str<M>) -> u64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    let mut occurrences = 0;\n    for i in 0..N {\n        if (match_count == M) {\n            temp_index = -1;\n            match_count = 0;\n            occurrences += 1;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        occurrences += 1;\n    }\n\n    occurrences\n}\n\nfn digit_at<N>(s: str<N>, index: u64) -> u8 {\n    let byte = s.as_bytes()[index];\n    assert((byte >= ZERO_INDEX) & (byte <= NINE_INDEX), \"Character is not a digit\");\n    byte - ZERO_INDEX\n}\n\nfn hex_digit_at<N>(s: str<N>, index: u64) -> u8 {\n    let byte = s.as_bytes()[index];\n    if (byte >= ZERO_INDEX) & (byte <= NINE_INDEX) {\n        byte - ZERO_INDEX\n    } else if (byte >= UPPERCASE_A_INDEX) & (byte <= UPPERCASE_Z_INDEX) {\n        byte - UPPERCASE_A_INDEX + 10\n    } else if (byte >= LOWERCASE_A_INDEX) & (byte <= LOWERCASE_Z_INDEX) {\n        byte - LOWERCASE_A_INDEX + 10\n    } else {\n        assert(false, \"Character is not a hex digit\");\n        0\n    }\n}\n\nfn to_uint_slice<N>(s: str<N>, start: u64, end: u64) -> u64 {\n    let mut result = 0;\n    for i in start..end {\n        let digit = digit_at(s, i);\n        result = result * 10 + digit as u64;\n    }\n    result\n}\n\nfn to_uint<N>(s: str<N>) -> u64 {\n    to_uint_slice(s, 0, N)\n}\n\nfn to_int<N>(s: str<N>) -> i64 {\n    if char_at(s, 0) == \"-\" {\n        -1 * to_uint_slice(s, 1, N) as i64\n    } else {\n        to_uint_slice(s, 0, N) as i64\n    }\n}\n\nfn from_hex_to_uint_slice<N>(s: str<N>, start: u64, end: u64) -> u64 {\n    let mut result = 0;\n    for i in start..end {\n        let digit = hex_digit_at(s, i);\n        result = result * 16 + digit as u64;\n    }\n    result\n}\n\nfn from_hex_to_uint<N>(s: str<N>, with_prefix: bool) -> u64 {\n    if with_prefix {\n        from_hex_to_uint_slice(s, 2, N)\n    } else {\n        from_hex_to_uint_slice(s, 0, N)\n    }\n}\n\nfn to_array_of_chars<N>(s: str<N>) -> [str<1>; N] {\n    let mut result: [str<1>; N] = [\" \"; N];\n    for i in 0..N {\n        result[i] = char_at(s, i);\n    }\n    result\n}\n\n// Struct\n\nstruct String<N> {\n    value: str<N>,\n    len: u64,\n}\n\n// Implementation over String struct\n\nimpl<N> String<N> {\n    fn new(value: str<N>) -> Self {\n        Self { value, len: N }\n    }\n\n    fn code_at(self: Self, index: u64) -> u8 {\n        code_at(self.value, index)\n    }\n\n    fn char_at(self: Self, index: u64) -> str<1> {\n        char_at(self.value, index)\n    }\n\n    fn index_of<M>(self: Self, substr: str<M>) -> i64 {\n        index_of(self.value, substr)\n    }\n\n    fn last_index_of<M>(self: Self, substr: str<M>) -> i64 {\n        last_index_of(self.value, substr)\n    }\n\n    fn indexes_of<M>(self: Self, substr: str<M>) -> Vec<Field> {\n        indexes_of(self.value, substr)\n    }\n\n    fn contains<M>(self: Self, substr: str<M>) -> bool {\n        contains(self.value, substr)\n    }\n\n    fn occurrences_of<M>(self: Self, substr: str<M>) -> u64 {\n        occurrences_of(self.value, substr)\n    }\n\n    fn digit_at(self: Self, index: u64) -> u8 {\n        digit_at(self.value, index)\n    }\n\n    fn hex_digit_at(self: Self, index: u64) -> u8 {\n        hex_digit_at(self.value, index)\n    }\n\n    fn to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        to_uint_slice(self.value, start, end)\n    }\n\n    fn to_uint(self: Self) -> u64 {\n        to_uint_slice(self.value, 0, self.len)\n    }\n\n    fn to_int(self: Self) -> i64 {\n        to_int(self.value)\n    }\n\n    fn from_hex_to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        from_hex_to_uint_slice(self.value, start, end)\n    }\n\n    fn from_hex_to_uint(self: Self, with_prefix: bool) -> u64 {\n        from_hex_to_uint(self.value, with_prefix)\n    }\n\n    fn to_array_of_chars(self: Self) -> [str<1>; N] {\n        to_array_of_chars(self.value)\n    }\n}\n\n// Trait\ntrait StringTrait {\n    fn code_at(self, index: u64) -> u8;\n    fn char_at(self, index: u64) -> str<1>;\n    fn index_of<M>(self, substr: str<M>) -> i64;\n    fn last_index_of<M>(self, c: str<M>) -> i64;\n    fn indexes_of<M>(self, c: str<M>) -> Vec<Field>;\n    fn contains<M>(self, substr: str<M>) -> bool;\n    fn occurrences_of<M>(self, c: str<M>) -> u64;\n    fn digit_at(self, index: u64) -> u8;\n    fn hex_digit_at(self, index: u64) -> u8;\n    fn to_uint_slice(self, start: u64, end: u64) -> u64;\n    fn to_uint(self) -> u64;\n    fn to_int(self) -> i64;\n    fn from_hex_to_uint_slice(self, start: u64, end: u64) -> u64;\n    fn from_hex_to_uint(self, with_prefix: bool) -> u64;\n}\n\n// Implementation for str type\nimpl<N> StringTrait for str<N> {\n    fn code_at(self: Self, index: u64) -> u8 {\n        code_at(self, index)\n    }\n\n    fn char_at(self: Self, index: u64) -> str<1> {\n        char_at(self, index)\n    }\n\n    fn index_of<M>(self: Self, substr: str<M>) -> i64 {\n        index_of(self, substr)\n    }\n\n    fn last_index_of<M>(self: Self, substr: str<M>) -> i64 {\n        last_index_of(self, substr)\n    }\n\n    fn indexes_of<M>(self: Self, substr: str<M>) -> Vec<Field> {\n        indexes_of(self, substr)\n    }\n\n    fn contains<M>(self: Self, substr: str<M>) -> bool {\n        contains(self, substr)\n    }\n\n    fn occurrences_of<M>(self: Self, substr: str<M>) -> u64 {\n        occurrences_of(self, substr)\n    }\n\n    fn digit_at(self: Self, index: u64) -> u8 {\n        digit_at(self, index)\n    }\n\n    fn hex_digit_at(self: Self, index: u64) -> u8 {\n        hex_digit_at(self, index)\n    }\n\n    fn to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        to_uint_slice(self, start, end)\n    }\n\n    fn to_uint(self: Self) -> u64 {\n        to_uint_slice(self, 0, N)\n    }\n\n    fn to_int(self: Self) -> i64 {\n        to_int(self)\n    }\n\n    fn from_hex_to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        from_hex_to_uint_slice(self, start, end)\n    }\n\n    fn from_hex_to_uint(self: Self, with_prefix: bool) -> u64 {\n        from_hex_to_uint(self, with_prefix)\n    }\n}\n\n// Tests for String struct\n#[test]\nfn test_init() {\n    let s = String::new(\"hello\");\n    assert(s.len == 5);\n    assert(s.value == \"hello\");\n}\n\n#[test]\nfn test_char_at() {\n    let s = String::new(\"hello\");\n    assert(s.char_at(0) == \"h\");\n    assert(s.char_at(1) == \"e\");\n    assert(s.char_at(2) == \"l\");\n    assert(s.char_at(3) == \"l\");\n    assert(s.char_at(4) == \"o\");\n}\n\n#[test]\nfn test_code_at() {\n    let s = String::new(\"hello\");\n    assert(s.code_at(0) == 104);\n    assert(s.code_at(1) == 101);\n    assert(s.code_at(2) == 108);\n    assert(s.code_at(3) == 108);\n    assert(s.code_at(4) == 111);\n}\n\n#[test]\nfn test_index_of() {\n    let s = String::new(\"hello\");\n    // Characters\n    assert(s.index_of(\"h\") == 0);\n    assert(s.index_of(\"e\") == 1);\n    assert(s.index_of(\"l\") == 2);\n    assert(s.index_of(\"o\") == 4);\n    assert(s.index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.index_of(\"he\") == 0);\n    assert(s.index_of(\"el\") == 1);\n    assert(s.index_of(\"ll\") == 2);\n    assert(s.index_of(\"lo\") == 3);\n    assert(s.index_of(\"hello\") == 0);\n    assert(s.index_of(\"ow\") == -1);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.index_of(\"some\") == 0);\n    assert(sentence.index_of(\"sentence\") == 5);\n    assert(sentence.index_of(\"with\") == 14);\n    assert(sentence.index_of(\"repetition\") == 24);\n    assert(sentence.index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.index_of(\"ti\") == 28);\n}\n\n#[test]\nfn test_last_index_of() {\n    let s = String::new(\"hello\");\n    assert(s.last_index_of(\"h\") == 0);\n    assert(s.last_index_of(\"e\") == 1);\n    assert(s.last_index_of(\"l\") == 3);\n    assert(s.last_index_of(\"o\") == 4);\n    assert(s.last_index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.last_index_of(\"he\") == 0);\n    assert(s.last_index_of(\"el\") == 1);\n    assert(s.last_index_of(\"ll\") == 2);\n    assert(s.last_index_of(\"lo\") == 3);\n    assert(s.last_index_of(\"hello\") == 0);\n    assert(s.last_index_of(\"ow\") == -1);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.last_index_of(\"some\") == 19);\n    assert(sentence.last_index_of(\"sentence\") == 5);\n    assert(sentence.last_index_of(\"with\") == 14);\n    assert(sentence.last_index_of(\"repetition\") == 24);\n    assert(sentence.last_index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.last_index_of(\"ti\") == 30);\n}\n\n#[test]\nfn test_indexes_of() {\n    let s = String::new(\"hello\");\n    assert(s.indexes_of(\"h\").get(0) == 0);\n    assert(s.indexes_of(\"e\").get(0) == 1);\n    assert(s.indexes_of(\"l\").get(0) == 2);\n    assert(s.indexes_of(\"l\").get(1) == 3);\n    assert(s.indexes_of(\"o\").get(0) == 4);\n    assert(s.indexes_of(\"a\").len() == 0);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.indexes_of(\"some\").get(0) == 0);\n    assert(sentence.indexes_of(\"some\").get(1) == 19);\n    assert(sentence.indexes_of(\"sentence\").get(0) == 5);\n    assert(sentence.indexes_of(\"with\").get(0) == 14);\n    assert(sentence.indexes_of(\"repetition\").get(0) == 24);\n    assert(sentence.indexes_of(\"some sentence with some repetition\").get(0) == 0);\n    assert(sentence.indexes_of(\"ti\").get(0) == 28);\n    assert(sentence.indexes_of(\"ti\").get(1) == 30);\n    assert(sentence.indexes_of(\"a\").len() == 0);\n}\n\n#[test]\nfn test_contains() {\n    let s = String::new(\"hello\");\n    assert(s.contains(\"h\"));\n    assert(s.contains(\"e\"));\n    assert(s.contains(\"l\"));\n    assert(s.contains(\"o\"));\n    assert(!s.contains(\"a\"));\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.contains(\"some\"));\n    assert(sentence.contains(\"sentence\"));\n    assert(sentence.contains(\"with\"));\n    assert(sentence.contains(\"repetition\"));\n    assert(sentence.contains(\"ti\"));\n    assert(!sentence.contains(\"hello\"));\n    assert(!sentence.contains(\"a\"));\n}\n\n#[test]\nfn test_occurrences_of() {\n    let s = String::new(\"hello\");\n    assert(s.occurrences_of(\"h\") == 1);\n    assert(s.occurrences_of(\"e\") == 1);\n    assert(s.occurrences_of(\"l\") == 2);\n    assert(s.occurrences_of(\"o\") == 1);\n    assert(s.occurrences_of(\"a\") == 0);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.occurrences_of(\"some\") == 2);\n    assert(sentence.occurrences_of(\"sentence\") == 1);\n    assert(sentence.occurrences_of(\"with\") == 1);\n    assert(sentence.occurrences_of(\"repetition\") == 1);\n    assert(sentence.occurrences_of(\"ti\") == 2);\n    assert(sentence.occurrences_of(\"hello\") == 0);\n    assert(sentence.occurrences_of(\"a\") == 0);\n}\n\n#[test]\nfn test_digit_at() {\n    let s = String::new(\"20231219\");\n    assert(s.digit_at(0) == 2);\n    assert(s.digit_at(1) == 0);\n    assert(s.digit_at(2) == 2);\n    assert(s.digit_at(3) == 3);\n    assert(s.digit_at(4) == 1);\n    assert(s.digit_at(5) == 2);\n    assert(s.digit_at(6) == 1);\n    assert(s.digit_at(7) == 9);\n}\n\n#[test]\nfn test_hex_digit_at() {\n    let s = String::new(\"0x1324ABCDEF\");\n    assert(s.hex_digit_at(2) == 1);\n    assert(s.hex_digit_at(3) == 3);\n    assert(s.hex_digit_at(4) == 2);\n    assert(s.hex_digit_at(5) == 4);\n    assert(s.hex_digit_at(6) == 10);\n    assert(s.hex_digit_at(7) == 11);\n    assert(s.hex_digit_at(8) == 12);\n    assert(s.hex_digit_at(9) == 13);\n    assert(s.hex_digit_at(10) == 14);\n    assert(s.hex_digit_at(11) == 15);\n}\n\n#[test]\nfn test_to_uint() {\n    let s = String::new(\"20231219\");\n    assert(s.to_uint() == 20231219);\n}\n\n#[test]\nfn test_to_int() {\n    let s = String::new(\"-25\");\n    assert(s.to_int() == -25);\n\n    let s = String::new(\"25\");\n    assert(s.to_int() == 25);\n}\n\n#[test]\nfn test_to_uint_slice() {\n    let s = String::new(\"2023/12/19\");\n    assert(s.to_uint_slice(0, 4) == 2023);\n    assert(s.to_uint_slice(5, 7) == 12);\n    assert(s.to_uint_slice(8, 10) == 19);\n}\n\n#[test]\nfn test_from_hex_to_uint_slice() {\n    let s = String::new(\"0x1324ABCDEF\");\n    assert(s.from_hex_to_uint_slice(2, 6) == 0x1324);\n    assert(s.from_hex_to_uint_slice(6, 9) == 0xABC);\n    assert(s.from_hex_to_uint_slice(9, 12) == 0xDEF);\n}\n\n#[test]\nfn test_from_hex_to_uint() {\n    let uppercase_hex = String::new(\"0x1324ABCDEF\");\n    assert(uppercase_hex.from_hex_to_uint(true) == 0x1324ABCDEF);\n\n    let lowercase_hex = String::new(\"0x1234abcdef\");\n    assert(lowercase_hex.from_hex_to_uint(true) == 0x1234ABCDEF);\n\n    let hex_without_prefix = String::new(\"1234abcdef\");\n    assert(hex_without_prefix.from_hex_to_uint(false) == 0x1234ABCDEF);\n\n    let hex_with_leading_zeros = String::new(\"0x000001\");\n    assert(hex_with_leading_zeros.from_hex_to_uint(true) == 1);\n}\n\n#[test]\nfn test_to_array_of_chars() {\n    let s = String::new(\"hello\");\n    let arr = s.to_array_of_chars();\n    assert(arr[0] == \"h\");\n    assert(arr[1] == \"e\");\n    assert(arr[2] == \"l\");\n    assert(arr[3] == \"l\");\n    assert(arr[4] == \"o\");\n}\n\n// Tests for String trait\n#[test]\nfn test_trait_char_at() {\n    let s = \"hello\";\n    assert(s.char_at(0) == \"h\");\n    assert(s.char_at(1) == \"e\");\n    assert(s.char_at(2) == \"l\");\n    assert(s.char_at(3) == \"l\");\n    assert(s.char_at(4) == \"o\");\n}\n\n#[test]\nfn test_trait_code_at() {\n    let s = \"hello\";\n    assert(s.code_at(0) == 104);\n    assert(s.code_at(1) == 101);\n    assert(s.code_at(2) == 108);\n    assert(s.code_at(3) == 108);\n    assert(s.code_at(4) == 111);\n}\n\n#[test]\nfn test_trait_index_of() {\n    let s = \"hello\";\n    // Characters\n    assert(s.index_of(\"h\") == 0);\n    assert(s.index_of(\"e\") == 1);\n    assert(s.index_of(\"l\") == 2);\n    assert(s.index_of(\"o\") == 4);\n    assert(s.index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.index_of(\"he\") == 0);\n    assert(s.index_of(\"el\") == 1);\n    assert(s.index_of(\"ll\") == 2);\n    assert(s.index_of(\"lo\") == 3);\n    assert(s.index_of(\"hello\") == 0);\n    assert(s.index_of(\"ow\") == -1);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.index_of(\"some\") == 0);\n    assert(sentence.index_of(\"sentence\") == 5);\n    assert(sentence.index_of(\"with\") == 14);\n    assert(sentence.index_of(\"repetition\") == 24);\n    assert(sentence.index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.index_of(\"ti\") == 28);\n}\n\n#[test]\nfn test_trait_last_index_of() {\n    let s = \"hello\";\n    // Characters\n    assert(s.last_index_of(\"h\") == 0);\n    assert(s.last_index_of(\"e\") == 1);\n    assert(s.last_index_of(\"l\") == 3);\n    assert(s.last_index_of(\"o\") == 4);\n    assert(s.last_index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.last_index_of(\"he\") == 0);\n    assert(s.last_index_of(\"el\") == 1);\n    assert(s.last_index_of(\"ll\") == 2);\n    assert(s.last_index_of(\"lo\") == 3);\n    assert(s.last_index_of(\"hello\") == 0);\n    assert(s.last_index_of(\"ow\") == -1);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.last_index_of(\"some\") == 19);\n    assert(sentence.last_index_of(\"sentence\") == 5);\n    assert(sentence.last_index_of(\"with\") == 14);\n    assert(sentence.last_index_of(\"repetition\") == 24);\n    assert(sentence.last_index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.last_index_of(\"ti\") == 30);\n}\n\n#[test]\nfn test_trait_indexes_of() {\n    let s = \"hello\";\n    assert(s.indexes_of(\"h\").get(0) == 0);\n    assert(s.indexes_of(\"e\").get(0) == 1);\n    assert(s.indexes_of(\"l\").get(0) == 2);\n    assert(s.indexes_of(\"l\").get(1) == 3);\n    assert(s.indexes_of(\"o\").get(0) == 4);\n    assert(s.indexes_of(\"a\").len() == 0);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.indexes_of(\"some\").get(0) == 0);\n    assert(sentence.indexes_of(\"some\").get(1) == 19);\n    assert(sentence.indexes_of(\"sentence\").get(0) == 5);\n    assert(sentence.indexes_of(\"with\").get(0) == 14);\n    assert(sentence.indexes_of(\"repetition\").get(0) == 24);\n    assert(sentence.indexes_of(\"some sentence with some repetition\").get(0) == 0);\n    assert(sentence.indexes_of(\"ti\").get(0) == 28);\n    assert(sentence.indexes_of(\"ti\").get(1) == 30);\n    assert(sentence.indexes_of(\"a\").len() == 0);\n}\n\n#[test]\nfn test_trait_contains() {\n    let s = \"hello\";\n    assert(s.contains(\"h\"));\n    assert(s.contains(\"e\"));\n    assert(s.contains(\"l\"));\n    assert(s.contains(\"o\"));\n    assert(!s.contains(\"a\"));\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.contains(\"some\"));\n    assert(sentence.contains(\"sentence\"));\n    assert(sentence.contains(\"with\"));\n    assert(sentence.contains(\"repetition\"));\n    assert(sentence.contains(\"ti\"));\n    assert(!sentence.contains(\"hello\"));\n    assert(!sentence.contains(\"a\"));\n}\n\n#[test]\nfn test_trait_occurrences_of() {\n    let s = \"hello\";\n    assert(s.occurrences_of(\"h\") == 1);\n    assert(s.occurrences_of(\"e\") == 1);\n    assert(s.occurrences_of(\"l\") == 2);\n    assert(s.occurrences_of(\"o\") == 1);\n    assert(s.occurrences_of(\"a\") == 0);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.occurrences_of(\"some\") == 2);\n    assert(sentence.occurrences_of(\"sentence\") == 1);\n    assert(sentence.occurrences_of(\"with\") == 1);\n    assert(sentence.occurrences_of(\"repetition\") == 1);\n    assert(sentence.occurrences_of(\"ti\") == 2);\n    assert(sentence.occurrences_of(\"hello\") == 0);\n    assert(sentence.occurrences_of(\"a\") == 0);\n}\n\n#[test]\nfn test_trait_digit_at() {\n    let s = \"20231219\";\n    assert(s.digit_at(0) == 2);\n    assert(s.digit_at(1) == 0);\n    assert(s.digit_at(2) == 2);\n    assert(s.digit_at(3) == 3);\n    assert(s.digit_at(4) == 1);\n    assert(s.digit_at(5) == 2);\n    assert(s.digit_at(6) == 1);\n    assert(s.digit_at(7) == 9);\n}\n\n#[test]\nfn test_trait_hex_digit_at() {\n    let s = \"0x1324ABCDEF\";\n    assert(s.hex_digit_at(2) == 1);\n    assert(s.hex_digit_at(3) == 3);\n    assert(s.hex_digit_at(4) == 2);\n    assert(s.hex_digit_at(5) == 4);\n    assert(s.hex_digit_at(6) == 10);\n    assert(s.hex_digit_at(7) == 11);\n    assert(s.hex_digit_at(8) == 12);\n    assert(s.hex_digit_at(9) == 13);\n    assert(s.hex_digit_at(10) == 14);\n    assert(s.hex_digit_at(11) == 15);\n}\n\n#[test]\nfn test_trait_to_uint() {\n    let s = \"20231219\";\n    assert(s.to_uint() == 20231219);\n}\n\n#[test]\nfn test_trait_to_int() {\n    let s = \"-25\";\n    assert(s.to_int() == -25);\n\n    let s = \"25\";\n    assert(s.to_int() == 25);\n}\n\n#[test]\nfn test_trait_to_uint_slice() {\n    let s = \"2023/12/19\";\n    assert(s.to_uint_slice(0, 4) == 2023);\n    assert(s.to_uint_slice(5, 7) == 12);\n    assert(s.to_uint_slice(8, 10) == 19);\n}\n\n#[test]\nfn test_trait_from_hex_to_uint_slice() {\n    let s = \"0x1324ABCDEF\";\n    assert(s.from_hex_to_uint_slice(2, 6) == 0x1324);\n    assert(s.from_hex_to_uint_slice(6, 9) == 0xABC);\n    assert(s.from_hex_to_uint_slice(9, 12) == 0xDEF);\n}\n\n#[test]\nfn test_trait_from_hex_to_uint() {\n    let uppercase_hex = \"0x1324ABCDEF\";\n    assert(uppercase_hex.from_hex_to_uint(true) == 0x1324ABCDEF);\n\n    let lowercase_hex = \"0x1234abcdef\";\n    assert(lowercase_hex.from_hex_to_uint(true) == 0x1234ABCDEF);\n\n    let hex_without_prefix = \"1234abcdef\";\n    assert(hex_without_prefix.from_hex_to_uint(false) == 0x1234ABCDEF);\n\n    let hex_with_leading_zeros = \"0x000001\";\n    assert(hex_with_leading_zeros.from_hex_to_uint(true) == 1);\n}\n","path":"/home/maximilien/nargo/github.com/madztheo/noir-string-utils.gitmain/src/lib.nr"}},"names":["main"]}
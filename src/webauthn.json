{"noir_version":"0.30.0+af57471035e4fa7eaffa71693219df6d029dbcde","hash":9631318694635974353,"abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":56},"visibility":"public"},{"name":"tx_hash_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"tx_hash","type":{"kind":"array","length":43,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"program_outputs","type":{"kind":"struct","path":"ProgramOutputs","fields":[{"name":"authenticator_data","type":{"kind":"array","length":37,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"client_data_json_len","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"client_data_json","type":{"kind":"array","length":255,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"public"}],"param_witnesses":{"identity":[{"start":12,"end":68}],"identity_len":[{"start":11,"end":12}],"initial_state":[{"start":2,"end":6}],"initial_state_len":[{"start":1,"end":2}],"next_state":[{"start":7,"end":11}],"next_state_len":[{"start":6,"end":7}],"program_outputs":[{"start":112,"end":533}],"tx_hash":[{"start":69,"end":112}],"tx_hash_len":[{"start":68,"end":69}],"version":[{"start":0,"end":1}]},"return_type":null,"return_witnesses":[],"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"1":{"source":"use crate::cmp::Ord;\n\n// TODO: Once we fully move to the new SSA pass this module can be removed and replaced\n// by the methods in the `slice` module\nimpl<T, N> [T; N] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u64 {}\n\n    pub fn sort(self) -> Self where T: Ord {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        let sorted_index = self.get_sorting_index(ordering);\n        let mut result = self;\n        // Ensure the indexes are correct\n        for i in 0..N {\n            let pos = find_index(sorted_index, i);\n            assert(sorted_index[pos] == i);\n        }\n        // Sort the array using the indexes\n        for i in 0..N {\n            result[i] = self[sorted_index[i]];\n        }\n        // Ensure the array is sorted\n        for i in 0..N - 1 {\n            assert(ordering(result[i], result[i + 1]));\n        }\n\n        result\n    }\n\n    /// Returns the index of the elements in the array that would sort it, using the provided custom sorting function.\n    unconstrained fn get_sorting_index<Env>(self, ordering: fn[Env](T, T) -> bool) -> [u64; N] {\n        let mut result = [0; N];\n        let mut a = self;\n        for i in 0..N {\n            result[i] = i;\n        }\n        for i in 1..N {\n            for j in 0..i {\n                if ordering(a[i], a[j]) {\n                    let old_a_j = a[j];\n                    a[j] = a[i];\n                    a[i] = old_a_j;\n                    let old_j = result[j];\n                    result[j] = result[i];\n                    result[i] = old_j;\n                }\n            }\n        }\n        result\n    }\n\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    // Apply a function to each element of an array, returning a new array\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the array and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given array as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the array satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the array satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\n// helper function used to look up the position of a value in an array of Field\n// Note that function returns 0 if the value is not found\nunconstrained fn find_index<N>(a: [u64; N], find: u64) -> u64 {\n    let mut result = 0;\n    for i in 0..a.len() {\n        if a[i] == find {\n            result = i;\n        }\n    }\n    result\n}\n","path":"std/array.nr"},"46":{"source":"use dep::std;\n\npub fn prefix_sha256_hash<N>(prefix_length: u8, input: [u8; N]) -> [u8; 32] {\n    let mut result = [0; 32];\n    assert([1, 2, 3, 113, 114, 133, 134, 156, 242, 243].any(|x| x == prefix_length), \"Length is not supported\");\n    if prefix_length == 1 {\n        result = std::hash::sha256(prefix(input, [0; 1]));\n    }\n    if prefix_length == 2 {\n        result = std::hash::sha256(prefix(input, [0; 2]));\n    }\n    if prefix_length == 3 {\n        result = std::hash::sha256(prefix(input, [0; 3]));\n    }\n    if prefix_length == 113 {\n        result = std::hash::sha256(prefix(input, [0; 113]));\n    }\n    if prefix_length == 114 {\n        result = std::hash::sha256(prefix(input, [0; 114]));\n    }\n    if prefix_length == 133 {\n        result = std::hash::sha256(prefix(input, [0; 133]));\n    }\n    if prefix_length == 134 {\n        result = std::hash::sha256(prefix(input, [0; 134]));\n    }\n    if prefix_length == 156 {\n        result = std::hash::sha256(prefix(input, [0; 156]));\n    }\n    if prefix_length == 242 {\n        result = std::hash::sha256(prefix(input, [0; 242]));\n    }\n    if prefix_length == 243 {\n        result = std::hash::sha256(prefix(input, [0; 243]));\n    }\n    result\n}\n\n\npub fn concatenate_arrays(a: [u8; 37], b: [u8; 32]) -> [u8; 69] {\n    let mut result = [0; 69];\n    for i in 0..37 {\n        result[i] = a[i];\n    }\n    for i in 0..32 {\n        result[i+37] = b[i];\n    }\n    result\n}\n\npub fn check_pubkey_matches_identity(pub_key_x: [u8; 32], pub_key_y: [u8; 32], identity: str<56>) {\n    // Compute the publickey as concatenation of pub_key_x and pub_key_y\n    let mut pub_key = [0; 64];\n    for i in 0..32 {\n        pub_key[i] = pub_key_x[i];\n    }\n    for j in 0..32 {\n        pub_key[j+32] = pub_key_y[j];\n    }\n    // Compute the address as the hash of the publickey\n    let address: [u8; 32] = std::hash::sha256(pub_key);\n\n    // identity is the last 20bytes of the address.\n    // Assert that there is a match between identity provided and identity computed from pubkeys\n    for k in 0..20 {\n        assert(address[12 + k] == identity.from_hex_to_uint_slice(2*k, 2*k + 2) as u8);\n    }\n}\n\n\nfn prefix<N, M>(input: [u8; N], mut result: [u8; M]) -> [u8; M] {\n    for i in 0..M {\n        result[i] = input[i];\n    }\n    result\n}","path":"/home/maximilien/cairo-erc20-runner/noir-webauthn/src/utils.nr"},"47":{"source":"mod utils;\n\nuse dep::std;\nuse dep::std::println;\nuse crate::utils::{prefix_sha256_hash, concatenate_arrays, check_pubkey_matches_identity};\n\nglobal CLIENT_DATA_JSON_LEN = 255;\n\nstruct ProgramOutputs {\n    authenticator_data: [u8; 37],\n    client_data_json_len: u8,\n    client_data_json: [u8; CLIENT_DATA_JSON_LEN],\n    signature: [u8; 64],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n}\n\n\nfn main(\n    version: pub u32,\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    identity_len: pub u8,\n    identity: pub str<56>,\n    tx_hash_len: pub u32,\n    tx_hash: pub [u8; 43],\n    program_outputs: pub ProgramOutputs\n) {\n    let client_data_json_hash = prefix_sha256_hash(program_outputs.client_data_json_len, program_outputs.client_data_json);\n    let concat = concatenate_arrays(program_outputs.authenticator_data, client_data_json_hash);\n    let hashed_data = std::hash::sha256(concat);\n\n    // Verifying pub_key matches the identity\n    check_pubkey_matches_identity(program_outputs.pub_key_x, program_outputs.pub_key_y, identity);\n\n\n    // The txhash IS the challenge\n    for i in 0..(tx_hash.len()) {\n        assert(tx_hash[i] == program_outputs.client_data_json[36 + i]);\n    }\n\n    let valid_signature = std::ecdsa_secp256r1::verify_signature(program_outputs.pub_key_x, program_outputs.pub_key_y, program_outputs.signature, hashed_data);\n    \n    assert(valid_signature);\n    assert(tx_hash_len == 43);\n    assert(identity_len == 56);\n}\n\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_134() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,125,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // Padding with 121 zeros (134+121 = 255) \n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        0,0,0,0,0,0,0,0,0\n    ];\n    let signature = [80,114,197,245,128,150,206,160,135,105,51,205,42,143,25,53,119,97,166,196,95,98,53,63,168,171,63,85,41,42,196,134,26,198,126,179,109,99,41,92,86,45,240,238,196,106,77,219,146,196,183,80,225,170,66,218,169,244,230,252,61,213,29,201];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [201,91,99,172,65,154,80,154,189,195,194,210,62,219,224,36,43,134,143,236,137,178,121,35,112,146,103,238,37,100,145,26];\n    let pub_key_y = [169,8,63,83,58,93,192,39,114,115,138,176,56,254,162,127,93,19,156,93,51,9,194,161,253,10,203,128,171,254,255,83];\n\n    let program_outputs = ProgramOutputs {\n            authenticator_data,\n            client_data_json_len: 134,\n            client_data_json,\n            signature,\n            pub_key_x,\n            pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 1;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 1;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 56;\n    let identity = \"c59b18d3bdaccb4d689048559a9bb6e8265293bf.ecdsa_secp256r1\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        program_outputs,\n    );\n}\n\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_243() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,44,34,111,116,104,101,114,95,107,101,121,115,95,99,97,110,95,98,101,95,97,100,100,101,100,95,104,101,114,101,34,58,34,100,111,32,110,111,116,32,99,111,109,112,97,114,101,32,99,108,105,101,110,116,68,97,116,97,74,83,79,78,32,97,103,97,105,110,115,116,32,97,32,116,101,109,112,108,97,116,101,46,32,83,101,101,32,104,116,116,112,115,58,47,47,103,111,111,46,103,108,47,121,97,98,80,101,120,34,125,\n        0,0,0,0,0,0,0,0,0,0,0,0 // Padding with 12 zeros (243+12 = 255) \n    ];\n    let signature = [35,9,110,138,212,71,172,124,13,7,194,158,153,63,87,67,67,25,22,122,101,253,159,175,106,50,52,157,164,70,148,46,126,152,146,190,137,37,199,95,249,115,198,94,237,198,18,23,200,185,52,157,189,205,144,63,212,29,177,20,24,255,160,127];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [15,206,241,12,21,160,54,11,79,72,44,109,43,45,101,54,210,243,13,236,51,33,47,66,187,38,60,249,64,70,37,252];\n    let pub_key_y = [43,221,114,86,240,184,224,51,237,41,173,85,147,130,225,150,159,150,44,23,57,92,82,37,27,40,69,123,252,224,3,197];\n    \n    let program_outputs = ProgramOutputs {\n        authenticator_data,\n        client_data_json_len: 243,\n        client_data_json,\n        signature,\n        pub_key_x,\n        pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 1;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 1;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 56;\n    let identity = \"3f368bf90c71946fc7b0cde9161ace42985d235f.ecdsa_secp256r1\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        program_outputs,\n    );\n}\n\n\n#[test]\nfn test_webauthn_verification_from_vibe_checker_243_bis() {\n    let authenticator_data = [73,150,13,229,136,14,140,104,116,52,23,15,100,118,96,91,143,228,174,185,162,134,50,199,153,92,243,186,131,29,151,99,1,0,0,0,2];\n    let client_data_json = [123,34,116,121,112,101,34,58,34,119,101,98,97,117,116,104,110,46,103,101,116,34,44,34,99,104,97,108,108,101,110,103,101,34,58,34,77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89,34,44,34,111,114,105,103,105,110,34,58,34,104,116,116,112,58,47,47,108,111,99,97,108,104,111,115,116,58,53,49,55,51,34,44,34,99,114,111,115,115,79,114,105,103,105,110,34,58,102,97,108,115,101,44,34,111,116,104,101,114,95,107,101,121,115,95,99,97,110,95,98,101,95,97,100,100,101,100,95,104,101,114,101,34,58,34,100,111,32,110,111,116,32,99,111,109,112,97,114,101,32,99,108,105,101,110,116,68,97,116,97,74,83,79,78,32,97,103,97,105,110,115,116,32,97,32,116,101,109,112,108,97,116,101,46,32,83,101,101,32,104,116,116,112,115,58,47,47,103,111,111,46,103,108,47,121,97,98,80,101,120,34,125,\n        0,0,0,0,0,0,0,0,0,0,0,0 // Padding with 12 zeros (243+12 = 255) \n    ];\n    let signature = [216,184,64,61,79,81,150,39,72,191,167,234,52,253,225,66,52,192,76,159,65,164,134,34,212,255,104,99,14,53,71,115,0,190,96,135,49,186,213,189,93,36,212,143,36,92,27,42,44,103,95,153,46,59,158,22,223,196,84,102,51,209,135,233];\n    let challenge = [77,68,69,121,77,122,81,49,78,106,99,52,79,87,70,105,89,50,82,108,90,106,65,120,77,106,77,48,78,84,89,51,79,68,108,104,89,109,78,107,90,87,89];\n    let pub_key_x = [35,250,194,235,47,86,159,70,36,137,145,195,83,245,203,137,12,28,43,171,167,226,44,90,199,107,235,0,229,229,133,67];\n    let pub_key_y = [84,107,152,100,72,140,98,57,186,30,76,187,129,194,209,158,96,37,254,211,60,198,27,227,167,247,204,51,145,53,120,95];\n\n    let program_outputs = ProgramOutputs {\n        authenticator_data,\n        client_data_json_len: 243,\n        client_data_json,\n        signature,\n        pub_key_x,\n        pub_key_y,\n    };\n\n    let version = 1;\n    let initial_state_len = 1;\n    let initial_state = [0, 0, 0, 0];\n    let next_state_len = 1;\n    let next_state = [0, 0, 0, 0];\n    let identity_len = 56;\n    let identity = \"ae0e5100ea7d28905ce690194c0717cd93756a20.ecdsa_secp256r1\";\n    let tx_hash_len = 43;\n    let tx_hash = challenge;\n\n    main(\n        version,\n        initial_state_len,\n        initial_state,\n        next_state_len,\n        next_state,\n        identity_len,\n        identity,\n        tx_hash_len,\n        tx_hash,\n        program_outputs,\n    );\n}\n","path":"/home/maximilien/cairo-erc20-runner/noir-webauthn/src/main.nr"},"48":{"source":"use dep::std::println;\n\nglobal UPPERCASE_A_INDEX: u8 = 65;\nglobal UPPERCASE_Z_INDEX: u8 = 90;\nglobal LOWERCASE_A_INDEX: u8 = 97;\nglobal LOWERCASE_Z_INDEX: u8 = 122;\nglobal ZERO_INDEX: u8 = 48;\nglobal NINE_INDEX: u8 = 57;\nglobal ASCII_TABLE_START_INDEX: u8 = 0;\nglobal SORTED_ASCII_TABLE: [str<1>; 127] = [    \n    \"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\t\",\"\\n\",\"\\0\",\"\\0\",\"\\r\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\"\\0\",\n    \" \",\"!\",\"\\\"\",\"#\",\"$\",\"%\",\"&\",\"'\",\"(\",\")\",\"*\",\"+\",\",\",\"-\",\".\",\"/\",\n    \"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\n    \":\",\";\",\"<\",\"=\",\">\",\"?\",\"@\",\n    \"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\",\n    \"[\",\"\\\\\",\"]\",\"^\",\"_\",\"`\",\n    \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\",\n    \"{\",\"|\",\"}\",\"~\"\n];\n\n// Functions \nfn code_at<N>(s: str<N>, index: u64) -> u8 {\n    assert(index < N);\n    s.as_bytes()[index]\n}\n\nfn char_at<N>(s: str<N>, index: u64) -> str<1> {\n    let byte = code_at(s, index);\n    let ascii_index = byte - ASCII_TABLE_START_INDEX;\n    SORTED_ASCII_TABLE[ascii_index]\n}\n\nfn index_of<N, M>(s: str<N>, substr: str<M>) -> i64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    for i in 0..N {\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            index = i as i64;\n            match_count += 1;\n        } else if (index != -1) & (i - index < M) {\n            if (str_bytes[i] != substr_bytes[i - index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    // If the match count is not equal to the length of the substring,\n    // then the substring is not in the string\n    // Can happen when looking at a substring that is at the end of the string\n    // but the match is only partial\n    if match_count != M {\n        index = -1;\n    }\n\n    index\n}\n\nfn last_index_of<N, M>(s: str<N>, substr: str<M>) -> i64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    let mut final_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    for i in 0..N {\n        if (match_count == M) {\n            final_index = temp_index;\n            temp_index = -1;\n            match_count = 0;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        final_index = temp_index;\n    }\n\n    final_index\n}\n\n// We use Field instead of integers for the Vector here as integers \n// don't seem to work well with Vectors at the moment\nfn indexes_of<N, M>(s: str<N>, substr: str<M>) -> Vec<Field> {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    let mut indexes: Vec<Field> = Vec::new();\n    for i in 0..N {\n        if (match_count == M) {\n            indexes.push(temp_index as Field);\n            temp_index = -1;\n            match_count = 0;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        indexes.push(temp_index as Field);\n    }\n\n    indexes\n}\n\nfn contains<N, M>(s: str<N>, substr: str<M>) -> bool {\n    index_of(s, substr) != -1\n}\n\nfn occurrences_of<N, M>(s: str<N>, substr: str<M>) -> u64 {\n    assert(M <= N, \"Substring length must be less than or equal to string length\");\n    let substr_bytes = substr.as_bytes();\n    let str_bytes = s.as_bytes();\n    let mut temp_index = -1 as i64;\n    // To keep track of how many characters of the substring\n    // have been found\n    let mut match_count = 0;\n    let mut occurrences = 0;\n    for i in 0..N {\n        if (match_count == M) {\n            temp_index = -1;\n            match_count = 0;\n            occurrences += 1;\n        }\n\n        // If the current character matches the first character of the substring\n        // and the index is not set, then set the index to the current index\n        if (temp_index == -1) & (str_bytes[i] == substr_bytes[0]) {\n            temp_index = i as i64;\n            match_count += 1;\n        } else if (temp_index != -1) & (i - temp_index < M) {\n            if (str_bytes[i] != substr_bytes[i - temp_index]) {\n                // If any of the subsequent characters don't match, reset the index\n                // as this means it's not the right substring\n                if (str_bytes[i] == substr_bytes[0]) {\n                    // If the current character matches the first character\n                    // of the substring, then set the index to the current\n                    temp_index = i as i64;\n                    match_count = 1;\n                } else {\n                    // Otherwise, reset the index\n                    temp_index = -1;\n                    match_count = 0;\n                }\n            } else {\n                // Here the characters match, so we increment the match count\n                match_count += 1;\n            }\n        }\n    }\n\n    if (match_count == M) & (temp_index != -1) {\n        occurrences += 1;\n    }\n\n    occurrences\n}\n\nfn digit_at<N>(s: str<N>, index: u64) -> u8 {\n    let byte = s.as_bytes()[index];\n    assert((byte >= ZERO_INDEX) & (byte <= NINE_INDEX), \"Character is not a digit\");\n    byte - ZERO_INDEX\n}\n\nfn hex_digit_at<N>(s: str<N>, index: u64) -> u8 {\n    let byte = s.as_bytes()[index];\n    if (byte >= ZERO_INDEX) & (byte <= NINE_INDEX) {\n        byte - ZERO_INDEX\n    } else if (byte >= UPPERCASE_A_INDEX) & (byte <= UPPERCASE_Z_INDEX) {\n        byte - UPPERCASE_A_INDEX + 10\n    } else if (byte >= LOWERCASE_A_INDEX) & (byte <= LOWERCASE_Z_INDEX) {\n        byte - LOWERCASE_A_INDEX + 10\n    } else {\n        assert(false, \"Character is not a hex digit\");\n        0\n    }\n}\n\nfn to_uint_slice<N>(s: str<N>, start: u64, end: u64) -> u64 {\n    let mut result = 0;\n    for i in start..end {\n        let digit = digit_at(s, i);\n        result = result * 10 + digit as u64;\n    }\n    result\n}\n\nfn to_uint<N>(s: str<N>) -> u64 {\n    to_uint_slice(s, 0, N)\n}\n\nfn to_int<N>(s: str<N>) -> i64 {\n    if char_at(s, 0) == \"-\" {\n        -1 * to_uint_slice(s, 1, N) as i64\n    } else {\n        to_uint_slice(s, 0, N) as i64\n    }\n}\n\nfn from_hex_to_uint_slice<N>(s: str<N>, start: u64, end: u64) -> u64 {\n    let mut result = 0;\n    for i in start..end {\n        let digit = hex_digit_at(s, i);\n        result = result * 16 + digit as u64;\n    }\n    result\n}\n\nfn from_hex_to_uint<N>(s: str<N>, with_prefix: bool) -> u64 {\n    if with_prefix {\n        from_hex_to_uint_slice(s, 2, N)\n    } else {\n        from_hex_to_uint_slice(s, 0, N)\n    }\n}\n\nfn to_array_of_chars<N>(s: str<N>) -> [str<1>; N] {\n    let mut result: [str<1>; N] = [\" \"; N];\n    for i in 0..N {\n        result[i] = char_at(s, i);\n    }\n    result\n}\n\n// Struct\n\nstruct String<N> {\n    value: str<N>,\n    len: u64,\n}\n\n// Implementation over String struct\n\nimpl<N> String<N> {\n    fn new(value: str<N>) -> Self {\n        Self { value, len: N }\n    }\n\n    fn code_at(self: Self, index: u64) -> u8 {\n        code_at(self.value, index)\n    }\n\n    fn char_at(self: Self, index: u64) -> str<1> {\n        char_at(self.value, index)\n    }\n\n    fn index_of<M>(self: Self, substr: str<M>) -> i64 {\n        index_of(self.value, substr)\n    }\n\n    fn last_index_of<M>(self: Self, substr: str<M>) -> i64 {\n        last_index_of(self.value, substr)\n    }\n\n    fn indexes_of<M>(self: Self, substr: str<M>) -> Vec<Field> {\n        indexes_of(self.value, substr)\n    }\n\n    fn contains<M>(self: Self, substr: str<M>) -> bool {\n        contains(self.value, substr)\n    }\n\n    fn occurrences_of<M>(self: Self, substr: str<M>) -> u64 {\n        occurrences_of(self.value, substr)\n    }\n\n    fn digit_at(self: Self, index: u64) -> u8 {\n        digit_at(self.value, index)\n    }\n\n    fn hex_digit_at(self: Self, index: u64) -> u8 {\n        hex_digit_at(self.value, index)\n    }\n\n    fn to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        to_uint_slice(self.value, start, end)\n    }\n\n    fn to_uint(self: Self) -> u64 {\n        to_uint_slice(self.value, 0, self.len)\n    }\n\n    fn to_int(self: Self) -> i64 {\n        to_int(self.value)\n    }\n\n    fn from_hex_to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        from_hex_to_uint_slice(self.value, start, end)\n    }\n\n    fn from_hex_to_uint(self: Self, with_prefix: bool) -> u64 {\n        from_hex_to_uint(self.value, with_prefix)\n    }\n\n    fn to_array_of_chars(self: Self) -> [str<1>; N] {\n        to_array_of_chars(self.value)\n    }\n}\n\n// Trait\ntrait StringTrait {\n    fn code_at(self, index: u64) -> u8;\n    fn char_at(self, index: u64) -> str<1>;\n    fn index_of<M>(self, substr: str<M>) -> i64;\n    fn last_index_of<M>(self, c: str<M>) -> i64;\n    fn indexes_of<M>(self, c: str<M>) -> Vec<Field>;\n    fn contains<M>(self, substr: str<M>) -> bool;\n    fn occurrences_of<M>(self, c: str<M>) -> u64;\n    fn digit_at(self, index: u64) -> u8;\n    fn hex_digit_at(self, index: u64) -> u8;\n    fn to_uint_slice(self, start: u64, end: u64) -> u64;\n    fn to_uint(self) -> u64;\n    fn to_int(self) -> i64;\n    fn from_hex_to_uint_slice(self, start: u64, end: u64) -> u64;\n    fn from_hex_to_uint(self, with_prefix: bool) -> u64;\n}\n\n// Implementation for str type\nimpl<N> StringTrait for str<N> {\n    fn code_at(self: Self, index: u64) -> u8 {\n        code_at(self, index)\n    }\n\n    fn char_at(self: Self, index: u64) -> str<1> {\n        char_at(self, index)\n    }\n\n    fn index_of<M>(self: Self, substr: str<M>) -> i64 {\n        index_of(self, substr)\n    }\n\n    fn last_index_of<M>(self: Self, substr: str<M>) -> i64 {\n        last_index_of(self, substr)\n    }\n\n    fn indexes_of<M>(self: Self, substr: str<M>) -> Vec<Field> {\n        indexes_of(self, substr)\n    }\n\n    fn contains<M>(self: Self, substr: str<M>) -> bool {\n        contains(self, substr)\n    }\n\n    fn occurrences_of<M>(self: Self, substr: str<M>) -> u64 {\n        occurrences_of(self, substr)\n    }\n\n    fn digit_at(self: Self, index: u64) -> u8 {\n        digit_at(self, index)\n    }\n\n    fn hex_digit_at(self: Self, index: u64) -> u8 {\n        hex_digit_at(self, index)\n    }\n\n    fn to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        to_uint_slice(self, start, end)\n    }\n\n    fn to_uint(self: Self) -> u64 {\n        to_uint_slice(self, 0, N)\n    }\n\n    fn to_int(self: Self) -> i64 {\n        to_int(self)\n    }\n\n    fn from_hex_to_uint_slice(self: Self, start: u64, end: u64) -> u64 {\n        from_hex_to_uint_slice(self, start, end)\n    }\n\n    fn from_hex_to_uint(self: Self, with_prefix: bool) -> u64 {\n        from_hex_to_uint(self, with_prefix)\n    }\n}\n\n// Tests for String struct\n#[test]\nfn test_init() {\n    let s = String::new(\"hello\");\n    assert(s.len == 5);\n    assert(s.value == \"hello\");\n}\n\n#[test]\nfn test_char_at() {\n    let s = String::new(\"hello\");\n    assert(s.char_at(0) == \"h\");\n    assert(s.char_at(1) == \"e\");\n    assert(s.char_at(2) == \"l\");\n    assert(s.char_at(3) == \"l\");\n    assert(s.char_at(4) == \"o\");\n}\n\n#[test]\nfn test_code_at() {\n    let s = String::new(\"hello\");\n    assert(s.code_at(0) == 104);\n    assert(s.code_at(1) == 101);\n    assert(s.code_at(2) == 108);\n    assert(s.code_at(3) == 108);\n    assert(s.code_at(4) == 111);\n}\n\n#[test]\nfn test_index_of() {\n    let s = String::new(\"hello\");\n    // Characters\n    assert(s.index_of(\"h\") == 0);\n    assert(s.index_of(\"e\") == 1);\n    assert(s.index_of(\"l\") == 2);\n    assert(s.index_of(\"o\") == 4);\n    assert(s.index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.index_of(\"he\") == 0);\n    assert(s.index_of(\"el\") == 1);\n    assert(s.index_of(\"ll\") == 2);\n    assert(s.index_of(\"lo\") == 3);\n    assert(s.index_of(\"hello\") == 0);\n    assert(s.index_of(\"ow\") == -1);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.index_of(\"some\") == 0);\n    assert(sentence.index_of(\"sentence\") == 5);\n    assert(sentence.index_of(\"with\") == 14);\n    assert(sentence.index_of(\"repetition\") == 24);\n    assert(sentence.index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.index_of(\"ti\") == 28);\n}\n\n#[test]\nfn test_last_index_of() {\n    let s = String::new(\"hello\");\n    assert(s.last_index_of(\"h\") == 0);\n    assert(s.last_index_of(\"e\") == 1);\n    assert(s.last_index_of(\"l\") == 3);\n    assert(s.last_index_of(\"o\") == 4);\n    assert(s.last_index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.last_index_of(\"he\") == 0);\n    assert(s.last_index_of(\"el\") == 1);\n    assert(s.last_index_of(\"ll\") == 2);\n    assert(s.last_index_of(\"lo\") == 3);\n    assert(s.last_index_of(\"hello\") == 0);\n    assert(s.last_index_of(\"ow\") == -1);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.last_index_of(\"some\") == 19);\n    assert(sentence.last_index_of(\"sentence\") == 5);\n    assert(sentence.last_index_of(\"with\") == 14);\n    assert(sentence.last_index_of(\"repetition\") == 24);\n    assert(sentence.last_index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.last_index_of(\"ti\") == 30);\n}\n\n#[test]\nfn test_indexes_of() {\n    let s = String::new(\"hello\");\n    assert(s.indexes_of(\"h\").get(0) == 0);\n    assert(s.indexes_of(\"e\").get(0) == 1);\n    assert(s.indexes_of(\"l\").get(0) == 2);\n    assert(s.indexes_of(\"l\").get(1) == 3);\n    assert(s.indexes_of(\"o\").get(0) == 4);\n    assert(s.indexes_of(\"a\").len() == 0);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.indexes_of(\"some\").get(0) == 0);\n    assert(sentence.indexes_of(\"some\").get(1) == 19);\n    assert(sentence.indexes_of(\"sentence\").get(0) == 5);\n    assert(sentence.indexes_of(\"with\").get(0) == 14);\n    assert(sentence.indexes_of(\"repetition\").get(0) == 24);\n    assert(sentence.indexes_of(\"some sentence with some repetition\").get(0) == 0);\n    assert(sentence.indexes_of(\"ti\").get(0) == 28);\n    assert(sentence.indexes_of(\"ti\").get(1) == 30);\n    assert(sentence.indexes_of(\"a\").len() == 0);\n}\n\n#[test]\nfn test_contains() {\n    let s = String::new(\"hello\");\n    assert(s.contains(\"h\"));\n    assert(s.contains(\"e\"));\n    assert(s.contains(\"l\"));\n    assert(s.contains(\"o\"));\n    assert(!s.contains(\"a\"));\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.contains(\"some\"));\n    assert(sentence.contains(\"sentence\"));\n    assert(sentence.contains(\"with\"));\n    assert(sentence.contains(\"repetition\"));\n    assert(sentence.contains(\"ti\"));\n    assert(!sentence.contains(\"hello\"));\n    assert(!sentence.contains(\"a\"));\n}\n\n#[test]\nfn test_occurrences_of() {\n    let s = String::new(\"hello\");\n    assert(s.occurrences_of(\"h\") == 1);\n    assert(s.occurrences_of(\"e\") == 1);\n    assert(s.occurrences_of(\"l\") == 2);\n    assert(s.occurrences_of(\"o\") == 1);\n    assert(s.occurrences_of(\"a\") == 0);\n\n    let sentence = String::new(\"some sentence with some repetition\");\n    assert(sentence.occurrences_of(\"some\") == 2);\n    assert(sentence.occurrences_of(\"sentence\") == 1);\n    assert(sentence.occurrences_of(\"with\") == 1);\n    assert(sentence.occurrences_of(\"repetition\") == 1);\n    assert(sentence.occurrences_of(\"ti\") == 2);\n    assert(sentence.occurrences_of(\"hello\") == 0);\n    assert(sentence.occurrences_of(\"a\") == 0);\n}\n\n#[test]\nfn test_digit_at() {\n    let s = String::new(\"20231219\");\n    assert(s.digit_at(0) == 2);\n    assert(s.digit_at(1) == 0);\n    assert(s.digit_at(2) == 2);\n    assert(s.digit_at(3) == 3);\n    assert(s.digit_at(4) == 1);\n    assert(s.digit_at(5) == 2);\n    assert(s.digit_at(6) == 1);\n    assert(s.digit_at(7) == 9);\n}\n\n#[test]\nfn test_hex_digit_at() {\n    let s = String::new(\"0x1324ABCDEF\");\n    assert(s.hex_digit_at(2) == 1);\n    assert(s.hex_digit_at(3) == 3);\n    assert(s.hex_digit_at(4) == 2);\n    assert(s.hex_digit_at(5) == 4);\n    assert(s.hex_digit_at(6) == 10);\n    assert(s.hex_digit_at(7) == 11);\n    assert(s.hex_digit_at(8) == 12);\n    assert(s.hex_digit_at(9) == 13);\n    assert(s.hex_digit_at(10) == 14);\n    assert(s.hex_digit_at(11) == 15);\n}\n\n#[test]\nfn test_to_uint() {\n    let s = String::new(\"20231219\");\n    assert(s.to_uint() == 20231219);\n}\n\n#[test]\nfn test_to_int() {\n    let s = String::new(\"-25\");\n    assert(s.to_int() == -25);\n\n    let s = String::new(\"25\");\n    assert(s.to_int() == 25);\n}\n\n#[test]\nfn test_to_uint_slice() {\n    let s = String::new(\"2023/12/19\");\n    assert(s.to_uint_slice(0, 4) == 2023);\n    assert(s.to_uint_slice(5, 7) == 12);\n    assert(s.to_uint_slice(8, 10) == 19);\n}\n\n#[test]\nfn test_from_hex_to_uint_slice() {\n    let s = String::new(\"0x1324ABCDEF\");\n    assert(s.from_hex_to_uint_slice(2, 6) == 0x1324);\n    assert(s.from_hex_to_uint_slice(6, 9) == 0xABC);\n    assert(s.from_hex_to_uint_slice(9, 12) == 0xDEF);\n}\n\n#[test]\nfn test_from_hex_to_uint() {\n    let uppercase_hex = String::new(\"0x1324ABCDEF\");\n    assert(uppercase_hex.from_hex_to_uint(true) == 0x1324ABCDEF);\n\n    let lowercase_hex = String::new(\"0x1234abcdef\");\n    assert(lowercase_hex.from_hex_to_uint(true) == 0x1234ABCDEF);\n\n    let hex_without_prefix = String::new(\"1234abcdef\");\n    assert(hex_without_prefix.from_hex_to_uint(false) == 0x1234ABCDEF);\n\n    let hex_with_leading_zeros = String::new(\"0x000001\");\n    assert(hex_with_leading_zeros.from_hex_to_uint(true) == 1);\n}\n\n#[test]\nfn test_to_array_of_chars() {\n    let s = String::new(\"hello\");\n    let arr = s.to_array_of_chars();\n    assert(arr[0] == \"h\");\n    assert(arr[1] == \"e\");\n    assert(arr[2] == \"l\");\n    assert(arr[3] == \"l\");\n    assert(arr[4] == \"o\");\n}\n\n// Tests for String trait\n#[test]\nfn test_trait_char_at() {\n    let s = \"hello\";\n    assert(s.char_at(0) == \"h\");\n    assert(s.char_at(1) == \"e\");\n    assert(s.char_at(2) == \"l\");\n    assert(s.char_at(3) == \"l\");\n    assert(s.char_at(4) == \"o\");\n}\n\n#[test]\nfn test_trait_code_at() {\n    let s = \"hello\";\n    assert(s.code_at(0) == 104);\n    assert(s.code_at(1) == 101);\n    assert(s.code_at(2) == 108);\n    assert(s.code_at(3) == 108);\n    assert(s.code_at(4) == 111);\n}\n\n#[test]\nfn test_trait_index_of() {\n    let s = \"hello\";\n    // Characters\n    assert(s.index_of(\"h\") == 0);\n    assert(s.index_of(\"e\") == 1);\n    assert(s.index_of(\"l\") == 2);\n    assert(s.index_of(\"o\") == 4);\n    assert(s.index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.index_of(\"he\") == 0);\n    assert(s.index_of(\"el\") == 1);\n    assert(s.index_of(\"ll\") == 2);\n    assert(s.index_of(\"lo\") == 3);\n    assert(s.index_of(\"hello\") == 0);\n    assert(s.index_of(\"ow\") == -1);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.index_of(\"some\") == 0);\n    assert(sentence.index_of(\"sentence\") == 5);\n    assert(sentence.index_of(\"with\") == 14);\n    assert(sentence.index_of(\"repetition\") == 24);\n    assert(sentence.index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.index_of(\"ti\") == 28);\n}\n\n#[test]\nfn test_trait_last_index_of() {\n    let s = \"hello\";\n    // Characters\n    assert(s.last_index_of(\"h\") == 0);\n    assert(s.last_index_of(\"e\") == 1);\n    assert(s.last_index_of(\"l\") == 3);\n    assert(s.last_index_of(\"o\") == 4);\n    assert(s.last_index_of(\"a\") == -1);\n\n    // Substrings\n    assert(s.last_index_of(\"he\") == 0);\n    assert(s.last_index_of(\"el\") == 1);\n    assert(s.last_index_of(\"ll\") == 2);\n    assert(s.last_index_of(\"lo\") == 3);\n    assert(s.last_index_of(\"hello\") == 0);\n    assert(s.last_index_of(\"ow\") == -1);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.last_index_of(\"some\") == 19);\n    assert(sentence.last_index_of(\"sentence\") == 5);\n    assert(sentence.last_index_of(\"with\") == 14);\n    assert(sentence.last_index_of(\"repetition\") == 24);\n    assert(sentence.last_index_of(\"some sentence with some repetition\") == 0);\n    assert(sentence.last_index_of(\"ti\") == 30);\n}\n\n#[test]\nfn test_trait_indexes_of() {\n    let s = \"hello\";\n    assert(s.indexes_of(\"h\").get(0) == 0);\n    assert(s.indexes_of(\"e\").get(0) == 1);\n    assert(s.indexes_of(\"l\").get(0) == 2);\n    assert(s.indexes_of(\"l\").get(1) == 3);\n    assert(s.indexes_of(\"o\").get(0) == 4);\n    assert(s.indexes_of(\"a\").len() == 0);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.indexes_of(\"some\").get(0) == 0);\n    assert(sentence.indexes_of(\"some\").get(1) == 19);\n    assert(sentence.indexes_of(\"sentence\").get(0) == 5);\n    assert(sentence.indexes_of(\"with\").get(0) == 14);\n    assert(sentence.indexes_of(\"repetition\").get(0) == 24);\n    assert(sentence.indexes_of(\"some sentence with some repetition\").get(0) == 0);\n    assert(sentence.indexes_of(\"ti\").get(0) == 28);\n    assert(sentence.indexes_of(\"ti\").get(1) == 30);\n    assert(sentence.indexes_of(\"a\").len() == 0);\n}\n\n#[test]\nfn test_trait_contains() {\n    let s = \"hello\";\n    assert(s.contains(\"h\"));\n    assert(s.contains(\"e\"));\n    assert(s.contains(\"l\"));\n    assert(s.contains(\"o\"));\n    assert(!s.contains(\"a\"));\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.contains(\"some\"));\n    assert(sentence.contains(\"sentence\"));\n    assert(sentence.contains(\"with\"));\n    assert(sentence.contains(\"repetition\"));\n    assert(sentence.contains(\"ti\"));\n    assert(!sentence.contains(\"hello\"));\n    assert(!sentence.contains(\"a\"));\n}\n\n#[test]\nfn test_trait_occurrences_of() {\n    let s = \"hello\";\n    assert(s.occurrences_of(\"h\") == 1);\n    assert(s.occurrences_of(\"e\") == 1);\n    assert(s.occurrences_of(\"l\") == 2);\n    assert(s.occurrences_of(\"o\") == 1);\n    assert(s.occurrences_of(\"a\") == 0);\n\n    let sentence = \"some sentence with some repetition\";\n    assert(sentence.occurrences_of(\"some\") == 2);\n    assert(sentence.occurrences_of(\"sentence\") == 1);\n    assert(sentence.occurrences_of(\"with\") == 1);\n    assert(sentence.occurrences_of(\"repetition\") == 1);\n    assert(sentence.occurrences_of(\"ti\") == 2);\n    assert(sentence.occurrences_of(\"hello\") == 0);\n    assert(sentence.occurrences_of(\"a\") == 0);\n}\n\n#[test]\nfn test_trait_digit_at() {\n    let s = \"20231219\";\n    assert(s.digit_at(0) == 2);\n    assert(s.digit_at(1) == 0);\n    assert(s.digit_at(2) == 2);\n    assert(s.digit_at(3) == 3);\n    assert(s.digit_at(4) == 1);\n    assert(s.digit_at(5) == 2);\n    assert(s.digit_at(6) == 1);\n    assert(s.digit_at(7) == 9);\n}\n\n#[test]\nfn test_trait_hex_digit_at() {\n    let s = \"0x1324ABCDEF\";\n    assert(s.hex_digit_at(2) == 1);\n    assert(s.hex_digit_at(3) == 3);\n    assert(s.hex_digit_at(4) == 2);\n    assert(s.hex_digit_at(5) == 4);\n    assert(s.hex_digit_at(6) == 10);\n    assert(s.hex_digit_at(7) == 11);\n    assert(s.hex_digit_at(8) == 12);\n    assert(s.hex_digit_at(9) == 13);\n    assert(s.hex_digit_at(10) == 14);\n    assert(s.hex_digit_at(11) == 15);\n}\n\n#[test]\nfn test_trait_to_uint() {\n    let s = \"20231219\";\n    assert(s.to_uint() == 20231219);\n}\n\n#[test]\nfn test_trait_to_int() {\n    let s = \"-25\";\n    assert(s.to_int() == -25);\n\n    let s = \"25\";\n    assert(s.to_int() == 25);\n}\n\n#[test]\nfn test_trait_to_uint_slice() {\n    let s = \"2023/12/19\";\n    assert(s.to_uint_slice(0, 4) == 2023);\n    assert(s.to_uint_slice(5, 7) == 12);\n    assert(s.to_uint_slice(8, 10) == 19);\n}\n\n#[test]\nfn test_trait_from_hex_to_uint_slice() {\n    let s = \"0x1324ABCDEF\";\n    assert(s.from_hex_to_uint_slice(2, 6) == 0x1324);\n    assert(s.from_hex_to_uint_slice(6, 9) == 0xABC);\n    assert(s.from_hex_to_uint_slice(9, 12) == 0xDEF);\n}\n\n#[test]\nfn test_trait_from_hex_to_uint() {\n    let uppercase_hex = \"0x1324ABCDEF\";\n    assert(uppercase_hex.from_hex_to_uint(true) == 0x1324ABCDEF);\n\n    let lowercase_hex = \"0x1234abcdef\";\n    assert(lowercase_hex.from_hex_to_uint(true) == 0x1234ABCDEF);\n\n    let hex_without_prefix = \"1234abcdef\";\n    assert(hex_without_prefix.from_hex_to_uint(false) == 0x1234ABCDEF);\n\n    let hex_with_leading_zeros = \"0x000001\";\n    assert(hex_with_leading_zeros.from_hex_to_uint(true) == 1);\n}\n","path":"/home/maximilien/nargo/github.com/madztheo/noir-string-utils.gitmain/src/lib.nr"}},"names":["main"]}